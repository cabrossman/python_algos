,folder,file,code,summary
0,B) two-three-pointers,5. Triplet Sum Close to Target.py,"
import math


def triplet_sum_close_to_target(arr, t):
arr.sort()

best_min = math.inf
for i in range(len(arr) -2):
left = i + 1
right = len(arr) - 1
while(left < right):
zsum = arr[i] + arr[left] + arr[right]
diff = t - zsum
if diff == 0:
return t


if abs(diff) < abs(best_min) or (
abs(diff) == abs(best_min)
and
diff > best_min
):
best_min = diff

if diff > 0:
left = left + 1
else:
right = right - 1
return t - best_min

","- Sorting the array in ascending order using `arr.sort()` is an important step to remember.
- The loop `for i in range(len(arr) -2)` is an important step to iterate through the array to find the triplet.
- The two while loops `while(left < right)` and `while(diff > 0)` are important steps to continue the search until the target sum is found or the pointers meet.
- Updating the `best_min` variable is an important step to keep track of the closest sum to the target."
1,B) two-three-pointers,8. Dutch National Flag.py,"
import math
import functools

def find_subarrays(arr):



return -1
","- The use of the ""import"" statement to bring in necessary modules (in this case, ""math"" and ""functools"").
- The creation of the function ""find_subarrays"" to perform the desired algorithm."
2,B) two-three-pointers,10.py,"
def backspace_compare(str1, str2):
s1_idx = len(str1) - 1
s2_idx = len(str2) - 1

while s1_idx > 0 or s2_idx > 0:

s1_c = 0
s2_c = 0
while str1[s1_idx - s1_c] == ""
s1_c = s1_c + 1
s1_idx = s1_idx - s1_c*2

while str2[s2_idx - s2_c] == ""
s2_c = s2_c + 1
s2_idx = s2_idx - s2_c*2

chr1 = str1[s1_idx]
chr2 = str2[s2_idx]
if s1_idx < 0 and s1_idx < 0:
return True
if s1_idx < 0 or s2_idx < 0:
return False
if chr1 != chr2:
return False

s1_idx = s1_idx - 1
s2_idx = s2_idx - 1

return True
","- The most important step to remember is the nested while loop that counts the number of consecutive backspace characters in each string (s1_c and s2_c) and updates the indices (s1_idx and s2_idx) accordingly.
- Another important step is comparing the characters (chr1 and chr2) at the current indices and returning False if they are not equal.
- Lastly, it is important to return True at the end of the function to indicate that the strings are the same after accounting for backspaces."
3,B) two-three-pointers,7. Subarrays with product less than target.py,"
import math
import functools

def find_subarrays(arr, t):
arr.sort()

return -1
",The most important step of this algorithm to remember is sorting the input array in ascending order.
4,B) two-three-pointers,12 sort_colors.py,"

def sort_colors(arr):

left, right = 0, len(arr) - 1
if len(arr) <= 1:
return arr
if len(arr) == 2:
if arr[0] < arr[1]:
return arr
else:
return [arr[1],arr[0]]
while left < right:
while arr[left] == 0: left += 1
while arr[right] == 2: right -= 1
if left > right:
break
mid = left + 1
lv, mv, rv = arr[left], arr[mid], arr[right]
if mv == 0 or rv == 0:
if mv < rv:
arr[left], arr[mid] = arr[mid], arr[left]
else:
arr[left], arr[right] = arr[right], arr[left]
left += 1
mid += 1
elif lv == 2 or mv == 2:
if lv > mv:
arr[right], arr[left] = arr[left], arr[right]
else:
arr[right], arr[mid] = arr[mid], arr[right]
right -= 1
else:
mid += 1
if mid >= right:
left += 1
mid = left + 1
return arr


def sortColors(nums):
low=mid=0
high=len(nums)-1
while mid<=high:
if nums[mid]==0:
nums[low],nums[mid]=nums[mid],nums[low]
low+=1
mid+=1
elif nums[mid]==1:
mid+=1
else:
nums[mid],nums[high]=nums[high],nums[mid]
high-=1
return nums

","The most important step to remember in the first algorithm is the swapping of elements to sort the colors. In the second algorithm, the most important step to remember is incrementing the pointers and swapping elements based on the color."
5,B) two-three-pointers,11 palendrome minus one.py,"

def pal_minus_one(s):
p1 = 0
p2 = len(s) - 1
while p1 < p2:
if s[p1] != s[p2]:
s1 = s[:p1] + s[(p1 + 1):]
s2 = s[:p2] + s[(p2 + 1):]
return s1 == s1[::-1] or s2 == s2[::-1]
p1 += 1
p2 -= 1
return True


","- The most important step to remember is the while loop that iterates through the string from both ends (p1 and p2) towards the middle.
- It is also important to understand the conditional statement that checks if s[p1] is not equal to s[p2]. This condition is crucial for identifying if a character needs to be removed from either end of the string."
6,B) two-three-pointers,9. Search Quadruplets.py,"
def search_quadruplets(arr, target):
quadruplets = set()
arr.sort()
for i in range(len(arr) - 3):
for j in range(i + 1,len(arr) - 2):
left = j + 1
right = len(arr) - 1
while(left < right):
quadruplet = (arr[i], arr[j], arr[left], arr[right])
if quadruplet in quadruplets:
left = left + 1
continue
_sum = sum(quadruplet)
if _sum == target:
quadruplets.add(quadruplet)
left = left + 1
elif _sum < target:
left = left + 1
else:
right = right - 1
return quadruplets
","The most important step to remember in this algorithm is:

- Sorting the input array `arr` before starting the search.

This is crucial because sorting the array allows us to utilize the two-pointer technique effectively and efficiently. It helps in finding all the possible quadruplets that sum up to the target value by maintaining a left and right pointer, which is only possible when the array is sorted."
7,B) two-three-pointers,334_increase_triplet_sequence.py,"def has_triplets(arr):
if len(arr) < 3:
return False
for mid, midV in enumerate(arr):
if mid == 0:
continue
left, leftV = mid - 1, arr[mid - 1]
right, rightV = len(arr) - 1, arr[len(arr) - 1]
while mid < right:
if leftV < midV and midV < rightV:
return True
if leftV > rightV:
right -= 1
rightV = arr[right]
else:
mid += 1
midV = arr[mid]
return False
","- The most important steps to remember in this algorithm are:
    1. Check if the length of the array is less than 3. If it is, return False.
    2. Iterate through the array, comparing the values of the current element (mid) with its neighbors (left and right).
    3. If the mid value is greater than the left value and less than the right value, return True.
    4. If the left value is greater than the right value, decrement the right index and update the right value.
    5. If none of the above conditions are met, increment the mid index and update the mid value.
    6. If the loop completes without finding any triplets, return False."
8,B) two-three-pointers,6. Triplets with Smaller Sum.py,"
import math

def triplet_with_smaller_sum(arr, t):
arr.sort()
triplets = []

for i in range(len(arr) -2):
left = i + 1
right = len(arr) - 1
while(left < right):
array = [arr[i], arr[left], arr[right]]
zsum = sum(array)
diff = t - zsum
tmp_right = right


while (i != left and i != right and left != right) and diff > 0:
triplets.append(array)


right = right - 1
array = [arr[i], arr[left], arr[right]]
zsum = sum(array)
diff = t - zsum
right = tmp_right
if diff > 0:
left = left + 1
else:
right = right - 1
return len(triplets)
","- The most important step to remember is to sort the array before starting the algorithm.
- Another important step is the nested while loop that checks for triplets that have a sum smaller than the target."
9,B) two-three-pointers,2. remove duplicates easy.py,"


def main(l):
length = len(l) - 1
nl = []
for i in range(len(l)):
if i < length:
left = l[i]
right = l[i + 1]
if left != right:
nl.append(left)
if nl[:-1] != right:
nl.append(right)

return len(nl)

","- The most important step to remember in this algorithm is to compare each element in the input list with its adjacent element and check if they are equal or not.
- Another important step is to append the non-equal elements from the input list into a new list, nl."
10,B) two-three-pointers,121_best_time_to_buy_stock.py,"

def max_prof(arr):
max_prof = 0
if len(arr) <= 1:
return max_prof
left, right = 0, 1

while right <= len(arr) - 1:
if arr[left] >= arr[right]:
left = right
right += 1
else:
curr_prof = arr[right] - arr[left]
max_prof = max(max_prof,curr_prof)
right += 1
return max_prof
","- The algorithm starts by initializing `max_prof` to 0
- If the size of the input array is less than or equal to 1, the algorithm returns the `max_prof` as it is and terminates
- The algorithm maintains two pointers `left` and `right` initially pointing to the first two elements of the input array
- The algorithm enters a while loop and continues until `right` exceeds the last valid index in the array
- Inside the while loop, the algorithm checks if the value at `left` is greater than or equal to the value at `right`
- If it is, the algorithm updates `left` to `right` and increments `right` by 1
- If it is not, the algorithm calculates the profit by subtracting the value at `left` from the value at `right`, and updates `max_prof` if the current profit is greater than `max_prof`
- In either case, the algorithm increments `right` by 1
- Finally, the algorithm returns the `max_prof`"
11,B) two-three-pointers,3. squaring a sorted array easy.py,"


def main(l):
left = 0
right = len(l) - 1
nl = [0 for i in range(len(l))]
nl_index = right
while left < right:
if abs(l[right]) >= abs(l[left]):
nl[nl_index] = l[right]**2
right = right - 1
nl_index = nl_index - 1
else:
nl[nl_index] = l[left]**2
left = left + 1
nl_index = nl_index - 1
return nl

","- Initialize pointers `left` and `right` to the start and end of the list respectively.
- Create a new list `nl` with the same length as the input list `l`.
- Initialize a variable `nl_index` to the index at the end of `nl`.
- Loop while `left` is less than `right`.
- Compare the absolute values of `l[right]` and `l[left]`.
- Square the greater absolute value and assign it to `nl[nl_index]`.
- Decrement `right` if the absolute value of `l[right]` is greater.
- Decrement `left` if the absolute value of `l[left]` is greater.
- Decrement `nl_index` after each assignment to `nl`.
- Repeat the process until `left` is not less than `right`.
- Return the modified list `nl`."
12,B) two-three-pointers,4. Triplet Sum to Zero (medium).py,"

def tripplets(arr):
arr.sort()
triplets = []
for i in range(len(arr)):
if i > 0 and arr[i] == arr[i-1]:
continue
left = i + 1
right = len(arr) - 1
while(left < right):
current_sum = arr[i] + arr[left] + arr[right]
if current_sum == 0:
triplets.append([arr[i], arr[left], arr[right]])
left += 1
right -= 1
while left < right and arr[left] == arr[left - 1]:
left += 1
while left < right and arr[right] == arr[right + 1]:
right -= 1
elif current_sum < 0:
left += 1
else:
right -= 1
return triplets
","- Sort the array before performing any operations.
- If the current element is equal to the previous element, skip it and move to the next iteration."
13,B) two-three-pointers,1. pair of target sum easy.py,"


def main(l, target):
left = 0
right = len(l) -1
while left < right:
ztotal = l[left] + l[right]
if ztotal == target:
return [left, right]
elif ztotal > target:
right = right - 1
else:
left = left + 1
return 0
","- Initialize the left pointer to the first element of the list and the right pointer to the last element of the list
- Repeat the following steps while the left pointer is less than the right pointer:
  - Calculate the total by summing the elements at the left and right pointers
  - If the total is equal to the target, return the indices of the left and right pointers
  - If the total is greater than the target, decrement the right pointer by 1
  - If the total is less than the target, increment the left pointer by 1
- If no match is found, return 0"
14,G) Breadth First Search,1. Binary Tree Level Traversal (easy).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None


def traverse(root):
result = []
if not root:
return result

queue = deque()
queue.append(root)
while queue:
levelSize = len(queue)
currentLevel = []
for _ in range(levelSize):
currentNode = queue.popleft()

currentLevel.append(currentNode.val)

if currentNode.left:
queue.append(currentNode.left)
if currentNode.right:
queue.append(currentNode.right)
result.append(currentLevel)
return result


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)",The most important step of this algorithm is the Breadth First Search traversal using a queue.
15,G) Breadth First Search,6. Connect Level Order Siblings (medium).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right, self.next = None, None, None


nextLevelRoot = self
while nextLevelRoot:
current = nextLevelRoot
nextLevelRoot = None
while current:
if not nextLevelRoot:
if current.left:
nextLevelRoot = current.left
elif current.right:
nextLevelRoot = current.right
current = current.next


def connect_level_order_siblings(root):
queue = deque()
queue.append(root)
while queue:
previous = None
level_size = len(queue)
for _ in range(level_size):
node = queue.popleft()
if previous:
previous.next = node
previous = node

if node.left:
queue.append(node.left)
if node.right:
queue.append(node.right)
return


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)
connect_level_order_siblings(root)
",The most important step to remember in this algorithm is to use a queue to perform a level order traversal of the tree. This allows you to connect the siblings at each level efficiently.
16,G) Breadth First Search,3. Zigzag Traversal (medium).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None


def traverse(root):
result = deque()
if not root:
return list(result)

queue = deque()
queue.append(root)
SWITCH = True
while queue:
levelSize = len(queue)
currentLevel = deque()
for _ in range(levelSize):
currentNode = queue.popleft()
if SWITCH:
currentLevel.append(currentNode.val)
else:
currentLevel.appendleft(currentNode.val)

if currentNode.left:
queue.append(currentNode.left)
if currentNode.right:
queue.append(currentNode.right)
result.append(list(currentLevel))
SWITCH = not SWITCH
return list(result)


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)
root.right.left.left = TreeNode(20)
root.right.left.right = TreeNode(17)","1. The most important step to remember in this algorithm is the use of a queue to traverse the tree level by level. The queue helps in maintaining the order of nodes to be processed and ensures that all nodes at a particular level are processed before moving on to the next level. 

2. Another important step is the use of the `SWITCH` variable to alternate between appending nodes to the currentLevel deque from the right or left side. This helps in achieving the zigzag pattern of traversal."
17,G) Breadth First Search,practice.py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None

class TreeNodeLL:
def __init__(self, val):
self.val = val
self.left, self.right, self.next = None, None, None


nextLevelRoot = self
while nextLevelRoot:
current = nextLevelRoot
nextLevelRoot = None
while current:
if not nextLevelRoot:
if current.left:
nextLevelRoot = current.left
elif current.right:
nextLevelRoot = current.right
current = current.next

def traverse(root):

result = []
if root is None:
return result

queue = deque()
queue.append(root)


while queue:





current_level_len = len(queue)
current_level_val = []
for _ in range(current_level_len):
current_node = queue.popleft()
current_level_val.append(current_node.val)
if current_node.left:
queue.append(current_node.left)
if current_node.right:
queue.append(current_node.right)

result.append(current_level_val)
return result

def traverse_bottom_to_top(root):
result = deque()
queue = deque()
queue.append(root)
while queue:
currentLevelLen = len(queue)
currentLevelVal = []
for _ in range(currentLevelLen):
current_node = queue.popleft()
currentLevelVal.append(current_node.val)
if current_node.left:
queue.append(current_node.left)
if current_node.right:
queue.append(current_node.right)
result.appendleft(currentLevelVal)
return list(result)

def connect_level_order_siblings(root):
queue = deque()
queue.append(root)
while queue:
previous = None
level_size = len(queue)
for _ in range(level_size):
node = queue.popleft()
if previous:
previous.next = node
previous = node

if node.left:
queue.append(node.left)
if node.right:
queue.append(node.right)
return

root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)

root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)


root = TreeNodeLL(12)
root.left = TreeNodeLL(7)
root.right = TreeNodeLL(1)
root.left.left = TreeNodeLL(9)
root.right.left = TreeNodeLL(10)
root.right.right = TreeNodeLL(5)
connect_level_order_siblings(root)
","1. The most important step to remember is to use a queue to perform level order traversal in the `traverse` and `traverse_bottom_to_top` functions. This ensures that the nodes are processed in the order they appear in each level.
2. Another important step to remember is to update the `next` pointer of the nodes in the `connect_level_order_siblings` function in order to connect the siblings at each level."
18,G) Breadth First Search,4. Level Averages in a Binary Tree (easy).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None


def traverse(root):
result = deque()
if not root:
return list(result)

queue = deque()
queue.append(root)
while queue:
levelSize = len(queue)
currentLevel = deque()
running_total = 0.0
for _ in range(levelSize):
currentNode = queue.popleft()
running_total = running_total + currentNode.val

if currentNode.left:
queue.append(currentNode.left)
if currentNode.right:
queue.append(currentNode.right)
result.append(running_total/levelSize)
return list(result)


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.left.right = TreeNode(2)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)","- The most important step to remember is to use a queue to perform a level order traversal of the binary tree.
- Another important step is to keep track of the level size to calculate the average at each level.
- Lastly, remember to append the average (running_total/levelSize) to the result list."
19,G) Breadth First Search,8.Right View of a Binary Tree (easy).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right, self.next = None, None, None


current = self
while current:
current = current.next


def tree_right_view(root):
result = []
queue = deque()
queue.append(root)
previous = None
while queue:
level_size = len(queue)
for i in range(level_size):
node = queue.popleft()
if node.left:
queue.append(node.left)
if node.right:
queue.append(node.right)
if i == level_size -1:
result.append(node.val)
return result


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)
root.left.left.left = TreeNode(3)
result = tree_right_view(root)","- The most important step to remember in this algorithm is to use a queue (implemented using `collections.deque`) to perform a level order traversal of the binary tree. 

- Another important step is to track the level size at each level of the tree using `level_size = len(queue)`. This helps in isolating the rightmost node at each level."
20,G) Breadth First Search,2. Reverse Level Order Traversal (easy).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None


def traverse(root):
result = deque()
if not root:
return result

queue = deque()
queue.append(root)
while queue:
levelSize = len(queue)
currentLevel = []
for _ in range(levelSize):
currentNode = queue.popleft()

currentLevel.append(currentNode.val)

if currentNode.left:
queue.append(currentNode.left)
if currentNode.right:
queue.append(currentNode.right)
result.appendleft(currentLevel)
result = list(result)
return result


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)","- The most important step to remember is to use a queue to implement a Breadth-First Search (BFS) traversal of the tree. This is done by initializing a deque and appending the root node to the deque.
- Another important step is to keep track of the current level of the traversal and store the nodes in that level in a temporary list. This is done by using a for loop to iterate through the nodes in the current level before moving on to the next level.
- Lastly, make sure to append the current level list to the left side of the result deque to ensure that the levels are stored in reverse order."
21,G) Breadth First Search,5. Minimum Depth Binary Tree (easy).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None


def find_minimum_depth(root):
if not root:
return 0

queue = deque()
queue.append(root)
levels = 0
while queue:
levelSize = len(queue)
for _ in range(levelSize):
currentNode = queue.popleft()

if currentNode.left:
queue.append(currentNode.left)
if currentNode.right:
queue.append(currentNode.right)
levels = levels + 1
return levels - 1


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)
root.left.left = TreeNode(9)
root.right.left.left = TreeNode(11)","The most important step in this algorithm is:

1. Keep track of the levels while traversing the tree by using a variable called ""levels"" and incrementing it each time a level is traversed. Finally, return ""levels - 1"" to get the minimum depth of the tree.

Note: The algorithm uses a breadth-first search approach using a queue to traverse the tree level by level. This allows us to find the minimum depth since the first leaf node encountered will have the minimum depth. Additionally, the algorithm takes care of edge cases such as an empty tree and nodes with only one child."
22,G) Breadth First Search,7. Connect All Level Order Siblings (medium).py,"

from collections import deque


class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right, self.next = None, None, None


current = self
while current:
current = current.next


def connect_all_siblings(root):
queue = deque()
queue.append(root)
previous = None
while queue:
level_size = len(queue)
for _ in range(level_size):
node = queue.popleft()
if previous:
previous.next = node
previous = node
if node.left:
queue.append(node.left)
if node.right:
queue.append(node.right)
return


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)
connect_all_siblings(root)","- The most important step to remember is the traversal of the tree level by level using a queue. This is done using a breadth-first search (BFS) approach where we process nodes level by level.
- Another important step is connecting the siblings in each level by updating the `next` pointer of each node to point to its right sibling. This is done by keeping track of the previous node and updating its `next` pointer to the current node."
23,H) Depth First Search,7. Flatten Binary Tree to LL copy.py,"class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def flatten(root):
if root is None:
return
p1 = root
while p1:
if p1.left:
p2 = p1.left
while p2.right:
p2 = p2.right
p2.right = p1.right
p1.right = p1.left
p1.left = None
p1 = p1.right
return root


root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(5)
root.left.left = TreeNode(3)
root.left.right = TreeNode(4)
root.right.right = TreeNode(6)

flatten(root)

current = root
while current:
current = current.right","The most important step in this algorithm is:
- Connecting the right subtree of the current node to the rightmost node of the left subtree."
24,H) Depth First Search,11. Flatten Tree to Array.py,"class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def flatten(root, data):
if root is None:
return
data.append(root.val)
flatten(root.left, data)
flatten(root.right, data)
return


root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(5)
root.left.left = TreeNode(3)
root.left.right = TreeNode(4)
root.right.right = TreeNode(6)

res = []
flatten(root, res)",The most important step to remember in this algorithm is to recursively traverse the tree and append the values of the nodes to the provided list.
25,H) Depth First Search,8. max depth of tree.py,"class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right

def max_depth(root):



if root is None:
return 0
left_depth = max_depth(root.left)
right_depth = max_depth(root.right)
return max(left_depth, right_depth) + 1

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.right.left = TreeNode(4)
root.right.left.left = TreeNode(6)
root.right.right = TreeNode(5)","The important step to remember in this algorithm is to calculate the maximum depth of the binary tree. This is done by checking if the root is None and returning 0, and then recursively calculating the maximum depth of the left and right subtrees. The maximum depth is determined by taking the maximum of the left and right depths and adding 1."
26,H) Depth First Search,3. Sum of Path Numbers (medium).py,"
from collections import deque

class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right

def find_sum_of_path_numbers(root):
all_paths = []
find_paths_recursive(
currentNode = root,
current_path = '',
all_paths = all_paths
)
return sum(path for path in all_paths)


def find_paths_recursive(currentNode, current_path, all_paths):
if currentNode is None:
return


current_path = current_path + str(currentNode.val)


if (
not currentNode.left
and not currentNode.right
):
all_paths.append(int(current_path))
else:

find_paths_recursive(
currentNode = currentNode.left,
current_path = current_path,
all_paths = all_paths
)

find_paths_recursive(
currentNode = currentNode.right,
current_path = current_path,
all_paths = all_paths
)


current_path = str(current_path[:-1])


root = TreeNode(1)
root.left = TreeNode(0)
root.right = TreeNode(1)
root.left.left = TreeNode(1)
root.right.left = TreeNode(6)
root.right.right = TreeNode(5)","- Define a helper function `find_paths_recursive` that takes `currentNode`, `current_path`, and `all_paths` as parameters. This function will be used to recursively find all paths from the root node to the leaf nodes.
- Initialize an empty list `all_paths` to store the sum of all path numbers.
- Call the `find_paths_recursive` function with the root node, an empty string `current_path`, and the `all_paths` list.
- In the `find_paths_recursive` function, check if the `currentNode` is None. If it is, return.
- Append the value of `currentNode` to the `current_path` string.
- Check if the `currentNode` does not have any left or right child nodes. If it doesn't, convert the `current_path` to an integer and append it to the `all_paths` list.
- Otherwise, recursively call the `find_paths_recursive` function for the left and right child nodes, passing the updated `current_path` and `all_paths` parameters.
- After the recursive calls, remove the last character from the `current_path` string to backtrack and explore other paths.
- Create a `TreeNode` object with the given values.
- Connect the nodes together to form a binary tree structure.
- Return the sum of all the path numbers in the `all_paths` list."
27,H) Depth First Search,12. array to BST.py,"from collections import deque

if root is None:
return

queue = deque([root])
while queue:
level_size = len(queue)
level_values = []
all_none = True
for _ in range(level_size):
node = queue.popleft()
if node:
level_values.append(node.val)
queue.append(node.left)
queue.append(node.right)
all_none = False
else:
level_values.append(None)
queue.append(None)
queue.append(None)
if all_none:
break

class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def sortedArrayToBST(nums):
if not nums:
return None

mid = len(nums) // 2
root = TreeNode(nums[mid])
root.left = sortedArrayToBST(nums[:mid])
root.right = sortedArrayToBST(nums[mid+1:])

return root

nums = [-10, -3, 0, 5, 9]
root = sortedArrayToBST(nums)
","- The most important step in the algorithm is the breadth-first search (BFS) traversal using a queue. This allows us to visit each node at a level before moving to the next level. This is crucial for constructing the binary tree from the sorted array and for printing the level-order traversal.
- Another important step is the recursive construction of the binary search tree (BST) from a sorted array. This ensures that the tree is balanced and maintains the property of a BST."
28,H) Depth First Search,1. Binary Tree Path Sum (easy).py,"
from collections import deque

class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right


def has_path(root, _sum):
if not root:
return False


if (
root.val == _sum
and not root.left
and not root.right
):
return True



left = has_path(root.left, _sum - root.val)
if left:
return True
right = has_path(root.right, _sum - root.val)
if right:
return True
return False



root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(9)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)",The most important step to remember in this algorithm is the recursive step of checking if there is a path in the tree that sums up to the given sum. This is done by subtracting the current node value from the sum and recursively checking if the left or right subtree has a path with the remaining sum.
29,H) Depth First Search,9. tree diameter2.py,"class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right

def depth_and_diameter(node):
if node is None:
return 0, 0

left_depth, left_diameter = depth_and_diameter(node.left)
right_depth, right_diameter = depth_and_diameter(node.right)


current_diameter = max(left_diameter, right_diameter, left_depth + right_depth)


current_depth = max(left_depth, right_depth) + 1

return current_depth, current_diameter

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.right.left = TreeNode(4)
root.right.left.left = TreeNode(6)
root.right.right = TreeNode(5)

depth, diameter = depth_and_diameter(root)
","- The most important step to remember in this algorithm is the recursive call to the `depth_and_diameter` function for the left and right child of the current node.
- Another important step is calculating the current diameter by comparing the diameter of the left child, the diameter of the right child, and the sum of the depths of the left and right child."
30,H) Depth First Search,14. validate BST.py,"class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def isValidBST(node, lower=float('-inf'), upper=float('inf')):
if not node:
return True
if node.val <= lower or node.val >= upper:
return False
if not isValidBST(node.right, node.val, upper):
return False
if not isValidBST(node.left, lower, node.val):
return False
return True

root = TreeNode(2)
root.left = TreeNode(1)
root.right = TreeNode(3)

root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(15)
root.left.left = TreeNode(2)
root.left.right = TreeNode(7)
root.right.left = TreeNode(12)
root.right.right = TreeNode(18)
","- The most important step is to ensure that the current node's value is within the valid range defined by the lower and upper bounds. If it is not, the tree is not a valid binary search tree and the function should return False.
- Another important step is to recursively check the validity of the right subtree, passing the current node's value as the new lower bound, and the current upper bound remains unchanged.
- Similarly, recursively check the validity of the left subtree, passing the current lower bound as the new lower bound, and the current node's value as the new upper bound.
- If all the recursive calls for the left and right subtrees return True and the current node passes the value validity check, then the function should return True, indicating that the tree is a valid binary search tree."
31,H) Depth First Search,13. lowest common ancestor.py,"class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None

def find_LCA(root, p, q):
if root is None:
return

if root.val == p or root.val == q:
return root

left_lca = find_LCA(root.left, p, q)
right_lca = find_LCA(root.right, p, q)


if left_lca and right_lca:
return root

return left_lca if left_lca else right_lca

root = TreeNode(3)
root.left = TreeNode(5)
root.right = TreeNode(1)
root.left.left = TreeNode(6)
root.left.right = TreeNode(2)
root.right.left = TreeNode(0)
root.right.right = TreeNode(8)

root.left.right.left = TreeNode(7)
root.left.right.right = TreeNode(4)
","The most important step to remember in this algorithm is the recursive calls to find the lowest common ancestor (LCA) of two nodes. This is done by recursively traversing the tree and checking if the current node is equal to either of the target nodes. If it is, the current node is returned as the LCA. If not, the algorithm continues traversing the left and right subtrees, and the LCA is determined based on the results of the recursive calls."
32,H) Depth First Search,4. Path With Given Sequence (medium).py,"

class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right


def find_path(root, sequence, current_seq = []):
if not root:
return False

current_seq.append(root.val)

if current_seq == sequence:
return True
else:

left = find_path(
root = root.left,
sequence = sequence,
current_seq = current_seq
)

right = find_path(
root = root.right,
sequence = sequence,
current_seq = current_seq
)
del current_seq[-1]
return left or right

root = TreeNode(1)
root.left = TreeNode(0)
root.right = TreeNode(1)
root.left.left = TreeNode(1)
root.right.left = TreeNode(6)
root.right.right = TreeNode(5)
","The most important step to remember in this algorithm is to recursively traverse the tree, appending each node value to the current sequence list."
33,H) Depth First Search,2. All Paths for a Sum (medium).py,"
from collections import deque

class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right

def find_paths(root, required_sum):
all_paths = []
find_paths_recursive(root, required_sum, [], all_paths)
return all_paths


def find_paths_recursive(currentNode, _sum, current_path, all_paths):
if currentNode is None:
return


current_path.append(currentNode.val)


if (
currentNode.val == _sum
and not currentNode.left
and not currentNode.right
):
all_paths.append(list(current_path))
else:

find_paths_recursive(
currentNode = currentNode.left,
_sum = _sum - currentNode.val,
current_path = current_path,
all_paths = all_paths
)

find_paths_recursive(
currentNode = currentNode.right,
_sum = _sum - currentNode.val,
current_path = current_path,
all_paths = all_paths
)


del current_path[-1]


root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(4)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)",The most important step to remember in this algorithm is the recursive function `find_paths_recursive`. This function is responsible for traversing the tree and finding all root-to-leaf paths that sum up to the required sum.
34,H) Depth First Search,5. Count Paths for a Sum (medium).py,"
class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right


def count_paths(root, _sum):
all_paths = []
cnt_paths_rec(
node = root,
_sum = _sum,
current_path = [],
all_paths = all_paths
)
return len(all_paths)

def cnt_paths_rec(node, _sum, current_path = [], all_paths = []):
if not node:
return

current_path.append(node.val)


if (
not node.left
and not node.right
):
tot = 0
for val in current_path[::-1]:
tot = tot + val
if tot == _sum:
all_paths.append(list(current_path))
else:

cnt_paths_rec(
node = node.left,
_sum = _sum,
current_path = current_path,
all_paths = all_paths
)

cnt_paths_rec(
node = node.right,
_sum = _sum,
current_path = current_path,
all_paths = all_paths
)
del current_path[-1]



root = TreeNode(12)
root.left = TreeNode(7)
root.right = TreeNode(1)
root.left.left = TreeNode(4)
root.right.left = TreeNode(10)
root.right.right = TreeNode(5)",One important step to remember in this algorithm is the recursive function `cnt_paths_rec`. It is used to traverse the tree and find all paths that sum to a given value.
35,H) Depth First Search,6.Tree Diameter (medium).py,"

class TreeNode:
def __init__(self, val, left=None, right=None):
self.val = val
self.left = left
self.right = right


def height(node):
if node is None:
return 0
left_h = height(node.left)
right_h = height(node.right)
return 1 + max(left_h, right_h)

def diameter(root):
if root is None:
return 0

left_max_h = height(root.left)
right_max_h = height(root.right)
potential_diam = left_max_h + right_max_h + 1

ldiameter = diameter(root.left)
rdiameter = diameter(root.right)

return max(ldiameter, rdiameter, potential_diam)


root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.right.left = TreeNode(5)
root.right.right = TreeNode(6)
root.left.left = None
root.right.left.left = TreeNode(7)
root.right.left.right = TreeNode(8)
root.right.right.left = TreeNode(9)
root.right.left.right.left = TreeNode(10)
root.right.right.left.left = TreeNode(11)
","- The most important step to remember in this algorithm is the calculation of the height of a tree node. This is done recursively by calculating the heights of the left and right subtrees and returning the maximum height plus 1.
- Another important step is the calculation of the potential diameter of a tree node, which is the sum of the maximum heights of the left and right subtrees plus 1. This potential diameter is compared with the diameters of the left and right subtrees, and the maximum among them is returned."
36,Q) Excel Title Online,num_to_title.py,"

def convertToTitle(idx):
column_string = ''
while idx > 0:
idx -= 1
column_string = chr((idx % 26) + ord('A')) + column_string
idx //= 26
return column_string




","- Subtract 1 from `idx` in the `while` loop: `idx -= 1`
- Convert the modulo result to a character using `chr()`, and add it to the `column_string`
- Perform integer division by 26: `idx //= 26`"
37,Q) Excel Title Online,title_to_num.py,"

def convertToInt(COLS):
tot = 0
for i, col in enumerate(COLS[::-1]):
char_int = ord(col) - ord('A') + 1
subtotal = char_int*(26**i)
tot = tot + subtotal
return tot



","1. `char_int = ord(col) - ord('A') + 1` - This step converts the letter to its corresponding integer value, starting with 1 for 'A'.  
2. `subtotal = char_int*(26**i)` - This step calculates the subtotal by multiplying the integer value of the letter with the appropriate power of 26 based on its position in the column string.  
3. `tot = tot + subtotal` - This step updates the total sum by adding the subtotal to it.  
4. `return tot` - This step returns the final sum as the converted integer value of the column."
38,L) Bitwise  XOR,practice.py,"from functools import reduce

def find_missing_number(arr):
n = len(arr) + 1

x1 = 1
for i in range(2, n+1):
x1 = x1 ^ i


x2 = arr[0]
for i in range(1, n-1):
x2 = x2 ^ arr[i]


return x1 ^ x2

def find_single_number(arr):
return reduce(lambda x, y: x ^ y, arr)

def find_single_numbers(nums):

n1xn2 = reduce(lambda x, y: x ^ y, nums)


rightmost_set_bit = 1
while (rightmost_set_bit & n1xn2) == 0:
rightmost_set_bit = rightmost_set_bit << 1
num1, num2 = 0, 0

for num in nums:
if (num & rightmost_set_bit) != 0:
num1 ^= num
else:
num2 ^= num

return [num1, num2]

def calculate_bitwise_complement(num):

bit_count, n = 0, num
while n > 0:
bit_count += 1
n = n >> 1





all_bits_set = pow(2, bit_count) - 1


return num ^ all_bits_set









","The most important step to remember in this algorithm is:

- In the `find_missing_number` function, calculate the XOR of all numbers from 1 to `n+1` and store it in `x1`. Then calculate the XOR of all elements in the given array `arr`, except the last one, and store it in `x2`. The missing number can be found by XORing `x1` and `x2`.

If we were to highlight one more step, it would be:

- In the `find_single_numbers` function, find the XOR of all elements in the `nums` array and store it in `n1xn2`. Then, find the rightmost set bit in `n1xn2`, and use it to separate the numbers into two groups. XORing all the numbers in each group will give the two single numbers.
"
39,L) Bitwise  XOR,0. test.py,"def find_missing_number(arr):
n = len(arr) + 1

x1 = 1
for i in range(2, n+1):
x1 = x1 ^ i


x2 = arr[0]
for i in range(1, n-1):
x2 = x2 ^ arr[i]


return x1 ^ x2

def main():
arr = [1, 5, 2, 6, 4]

main()","- The first important step is to calculate the value of `n` by getting the length of the array `arr` and adding 1 to it.
- The second important step is to calculate `x1` by performing XOR operations on the range from 1 to `n+1`.
- The third important step is to calculate `x2` by performing XOR operations on the elements of the array starting from index 0.
- The final important step is to return the result of performing XOR operation on `x1` and `x2`."
40,L) Bitwise  XOR,1. Single Number.py,"
from functools import reduce

def find_single_number(arr):
return reduce(lambda x, y: x ^ y, arr)
","- Importing the `reduce` function from the `functools` module.
- Using the `reduce` function along with the lambda function and the `xor` operator (`^`) to find the single number in the array."
41,L) Bitwise  XOR,3. Base 10 (medium).py,"
def calculate_bitwise_complement(num):

bit_count, n = 0, num
while n > 0:
bit_count += 1
n = n >> 1





all_bits_set = pow(2, bit_count) - 1


return num ^ all_bits_set

","- The most important step to remember is calculating the bit count by counting the number of bits in the given number `num` using a while loop and bit shifting (`n = n >> 1` and `bit_count += 1`).
- Another important step is calculating `all_bits_set` by using the formula `all_bits_set = pow(2, bit_count) - 1` which sets all the bits in `all_bits_set` to 1.
- Lastly, returning the bitwise complement of `num` by performing an XOR operation between `num` and `all_bits_set` (`return num ^ all_bits_set`)."
42,L) Bitwise  XOR,2. Two Single Numbers (medium).py,"
from functools import reduce

def find_single_numbers(nums):

n1xn2 = reduce(lambda x, y: x ^ y, nums)


rightmost_set_bit = 1
while (rightmost_set_bit & n1xn2) == 0:
rightmost_set_bit = rightmost_set_bit << 1
num1, num2 = 0, 0

for num in nums:
if (num & rightmost_set_bit) != 0:
num1 ^= num
else:
num2 ^= num

return [num1, num2]

arr = [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]

arr = [2, 1, 3, 2]","The most important step to remember in this algorithm is:
- XORing all the numbers in the list to get the XOR of the two single numbers (n1xn2)
- Finding the rightmost set bit in n1xn2
- Using the rightmost set bit to divide the numbers into two groups and XORing the numbers in each group separately to get the single numbers (num1 and num2)"
43,N) K-Way Merge,1. Merge K Sorted Lists (medium).py,"

from heapq import heappush, heappop


class ListNode:
def __init__(self, value):
self.value = value
self.next = None


def __lt__(self, other):
return self.value < other.value


def merge_lists(lists):
minHeap = []

for root in lists:
if root:
heappush(minHeap, root)



resultHead, resultTail = None, None
while minHeap:
node = heappop(minHeap)
if resultHead is None:
resultHead = resultTail = node
else:
resultTail.next = node
resultTail = resultTail.next

if node.next:
heappush(minHeap, node.next)

return resultHead

def format_output(node):
l = []
while node:
l.append(node.value)
node = node.next
return l


l1 = ListNode(2)
l1.next = ListNode(6)
l1.next.next = ListNode(8)

l2 = ListNode(3)
l2.next = ListNode(6)
l2.next.next = ListNode(7)

l3 = ListNode(1)
l3.next = ListNode(3)
l3.next.next = ListNode(4)

result = merge_lists([l1, l2, l3])
result = format_output(result)


l1 = ListNode(5)
l1.next = ListNode(8)
l1.next.next = ListNode(9)

l2 = ListNode(1)
l2.next = ListNode(7)

result = merge_lists([l1, l2])
result = format_output(result)
","The most important step to remember in this algorithm is:

1. Creating a Min Heap to store the roots of the linked lists.
2. Checking if the root is not None before adding it to the Min Heap.
3. Maintaining two pointers, resultHead, and resultTail, to keep track of the merged list.
4. Comparing the node values using the __lt__ method of the ListNode class.
5. Checking if the node has a next element before pushing it back into the Min Heap.
6. Returning the final merged linked list by returning the resultHead.
7. Converting the merged linked list into a list format using the format_output function."
44,N) K-Way Merge,2. Kth Smallest Number in M Sorted Lists (Medium).py,"

from heapq import *


class ListNode:
def __init__(self, value):
self.value = value
self.next = None


def __lt__(self, other):
return self.value < other.value


def find_Kth_smallest(lists, K):
minHeap = []


for root in lists:
if root:
heappush(minHeap, root)



resultHead, resultTail = None, None
cnt = 0
while minHeap:
node = heappop(minHeap)
cnt = cnt + 1
if cnt == K:
return node.value
if resultHead is None:
resultHead = resultTail = node
else:
resultTail.next = node
resultTail = resultTail.next

if node.next:
heappush(minHeap, node.next)

return resultHead


l1 = ListNode(2)
l1.next = ListNode(6)
l1.next.next = ListNode(8)

l2 = ListNode(3)
l2.next = ListNode(6)
l2.next.next = ListNode(7)

l3 = ListNode(1)
l3.next = ListNode(3)
l3.next.next = ListNode(4)



l1 = ListNode(5)
l1.next = ListNode(8)
l1.next.next = ListNode(9)

l2 = ListNode(1)
l2.next = ListNode(7)

","The most important step to remember in this algorithm is to use a min heap to store the elements from the input lists. Heappush and heappop functions from the heapq module are used to push elements into the heap and pop the minimum element from the heap, respectively."
45,N) K-Way Merge,3. Merge K Stored Arrays.py,"from heapq import heappush, heappop

def merge(lists):
min_heap = []
result = []


array_map ={f'l{i + 1}': l for i, l in enumerate(lists)}

for list_id, lst in array_map.items():
pointer = 0
n = lst[pointer]
tup = (n, pointer, list_id)
heappush(min_heap, tup)

while min_heap:
(n, pointer, list_id) = heappop(min_heap)
result.append(n)
if pointer + 1 < len(array_map[list_id]):
n = array_map[list_id][pointer + 1]
pointer += 1
tup = (n, pointer, list_id)
heappush(min_heap, tup)

return result


l1 = [2, 5, 8]
l2 = [1, 3, 6, 9]
l3 = [4, 5, 6, 7, 10]
result = merge([l1, l2, l3])","- The most important step to remember in this algorithm is to use a min-heap to maintain the smallest elements from each list. This is achieved using the heappush and heappop functions from the heapq module.
- Another important step is to update the pointer and add the next element from the list to the min-heap whenever an element is popped from the heap. This is done to continue merging the lists until all elements have been added to the result."
46,K) Modified Binary Search,1. Order Agnostic Binary Search.py,"

def binary_search(arr, key):

start, end = 0, len(arr) -1
ASC_ORDER = True if arr[0] < arr[-1] else False

while start <= end:
mid = (end - start)//2 + start
if arr[mid] == key:
return mid

if ASC_ORDER:
if arr[mid] > key:
end = mid - 1
else:
start = mid + 1
else:
if arr[mid] < key:
end = mid - 1
else:
start = mid + 1
return -1

","The most important step to remember in this binary search algorithm is to correctly update the ""start"" and ""end"" pointers depending on whether the array is in ascending or descending order."
47,K) Modified Binary Search,278_first_bad_version.py,"

def badv(versions, isBadVersion):
left, right = 0, versions
while left < right:
mid = (right - left)//2 + left
if isBadVersion(mid):
right = mid
else:
left = mid + 1
return left if isBadVersion(left) else -1


isBadVersion = lambda version: version >= 1

isBadVersion = lambda version: version >= 6

isBadVersion = lambda version: version >= 1

isBadVersion = lambda version: version >= 4

","- The most important step is to implement the binary search algorithm correctly, which involves updating the left and right pointers based on the mid value and the isBadVersion function.
- Another important step is to make sure the termination condition of the while loop is correct, in this case, left < right, to ensure that the loop does not run indefinitely."
48,K) Modified Binary Search,7. Bitonic Array Maximum (easy).py,"

def find_max_in_bitonic_array(arr):
start, end = 0, len(arr) -1
while start <= end:
mid = (end - start)//2 + start
if arr[mid] > arr[mid + 1]:
end = mid
else:
start = mid + 1
return arr[start]
","- The most important step is to update the start or end index based on the comparison of the current element with its next element in the bitonic array. If the current element is greater than its next element, then the maximum element must be on the left side of the current element, so update the end index to mid. Otherwise, update the start index to mid + 1."
49,K) Modified Binary Search,8. Proglem Challenge 1 (medium).py,"

def search_bitonic_array(arr, key):
start, end = 0, len(arr) -1
while start <= end:
mid = (end - start)//2 + start
val = arr[mid]
if val == key:
return mid
if mid < len(arr) - 1:
increasing = val < arr[mid + 1]
else:
increasing = False
if increasing:
if key > val:
start = mid + 1
else:
end = mid - 1
else:
if key < val:
start = mid + 1
else:
end = mid - 1
return -1
","The most important step to remember in this algorithm is to update the start and end pointers based on whether the current value at the midpoint is increasing or decreasing, and whether the key is greater or smaller than the current value."
50,K) Modified Binary Search,9. Search in Pivoted Array.py,"def search(nums, target):
low, high = 0, len(nums) -1
while low <= high:
mid = low + (high - low) // 2
if nums[mid] == target:
return mid

if nums[low] <= nums[mid]:
if nums[low] <= target and target < nums[mid]:
high = mid - 1
else:
low = mid + 1
else:
if nums[mid] < target and target <= nums[high]:
low = mid + 1
else:
high = mid - 1
return -1
","1. The most important step is to calculate the midpoint of the list using the formula ""mid = low + (high - low) // 2"".

2. Another important step is to check if the target is equal to the number at the midpoint of the list. If it is, return the index of the midpoint.

3. Additionally, it is important to update the values of ""low"" and ""high"" depending on whether the target is within the range of the numbers on the left or right side of the midpoint."
51,K) Modified Binary Search,2. Ceiling of a Number.py,"

def binary_search(arr, key):
start, end = 0, len(arr) -1
while start <= end:
mid = (end - start)//2 + start
if arr[mid] == key:
return mid
if key < arr[mid]:
end = mid - 1
else:
start = mid + 1


start, end = end, start
end = end if end < len(arr) - 1 else len(arr) - 1
start = start if start >= 0 else 0
if key > arr[end]:
return -1
if key < arr[start]:
return start
return end

","- The most important step to remember is implementing the binary search itself. 
- Another important step is handling the cases where the key is not found in the array, checking if it is greater than the maximum element or smaller than the minimum element."
52,K) Modified Binary Search,4. Number Range (medium).py,"

def binary_search(arr, key):

start, end = 0, len(arr) -1

while start <= end:
mid = (end - start)//2 + start
if arr[mid] == key:
start, end = mid, mid
while start > 0 and arr[start - 1] == key:
start = start - 1
while end < len(arr) - 1 and arr[end + 1] == key:
end = end + 1
return [start, end]
if key < arr[mid]:

end = mid - 1
else:

start = mid + 1
return [-1,-1]


","- The most important step in this algorithm is to update the ""start"" and ""end"" indexes during each iteration of the while loop. These indexes are used to divide the search space in half, allowing the algorithm to efficiently find the target element."
53,K) Modified Binary Search,162. Find Peak Element.py,"



def find_peak(nums):
if len(nums) < 3:
return -1
if nums[0] > nums[1]:
return 0
if nums[len(nums) - 1] > nums[len(nums) - 2]:
return len(nums) - 1
left, right = 0, len(nums) - 1
while left < right:
mid = (left + right) // 2
if nums[mid] < nums[mid + 1]:
left = mid + 1
else:
right = mid
return left


","- First, check if the length of the input list `nums` is less than 3. If it is, return -1.
- If the first number in the list (`nums[0]`) is greater than the second number (`nums[1]`), return 0.
- If the last number in the list (`nums[len(nums) - 1]`) is greater than the second to last number (`nums[len(nums) - 2]`), return the index of the last number in the list (`len(nums) - 1`).
- If none of the above conditions are met, initialize the variables `left` and `right` with the values 0 and `len(nums) - 1` respectively.
- Use a binary search algorithm to find the peak element, by repeatedly updating the values of `left` and `right` until the condition `left < right` is no longer true.
- Within the while loop, calculate the mid index `mid` using integer division (`//`) of the sum of `left` and `right` divided by 2.
- If the value at `nums[mid]` is less than the value at `nums[mid + 1]`, update `left` to be `mid + 1`.
- Otherwise, update `right` to be `mid`.
- Finally, return the value of `left`, which will be the index of the peak element in the list."
54,K) Modified Binary Search,6 Minimum Diff Element (medium).py,"

def search_min_diff_element(arr, key):
start, end = 0, len(arr) -1
while start <= end:
mid = (end - start)//2 + start
if key > arr[mid]:
start = mid + 1
elif key < arr[mid]:
end = mid - 1
else:
return arr[mid]


end = start

end = end if end < len(arr) - 1 else len(arr) - 1

start = end - 1


start_diff = abs(key - arr[start])
end_diff = abs(key - arr[end])
if start_diff < end_diff:
return arr[start]
else:
return arr[end]
","1. The most important step to remember in this algorithm is the binary search step, performed in the while loop. This step helps to narrow down the search space and find the element with the minimum difference to the key.

2. Another important step to remember is the calculation of start_diff and end_diff. These variables are used to compare the differences between the key and the elements at start and end indices, in order to determine which one has the minimum difference."
55,K) Modified Binary Search,5. Search in a Sorted Infinite Array (medium).py,"

import math


class ArrayReader:

def __init__(self, arr):
self.arr = arr

def get(self, index):
if index >= len(self.arr):
return math.inf
return self.arr[index]


def binary_search(reader, key, start, end):
while start <= end:
mid = (end - start)//2 + start
val = reader.get(mid)
if key > val:
start = mid + 1
elif key < val:
end = mid - 1
else:
return mid
return -1

def search_in_infinite_array(reader, key):
start, end = 0,1
while reader.get(end) < key:
start = end + 1
end = (end + 1)*2

return binary_search(reader, key, start, end)


reader = ArrayReader([4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30])
search_in_infinite_array(reader, 16) == 6
reader = ArrayReader([1, 3, 8, 10, 15])","- The most important step of this algorithm is the binary search implementation, which is performed in the `binary_search` function.
- Another important step is updating the `start` and `end` variables in the `search_in_infinite_array` function to find the range in which the key might be present."
56,K) Modified Binary Search,3. Next Letter (medium).py,"

def binary_search(arr, key):

start, end = 0, len(arr) -1

while start <= end:

mid = (end - start)//2 + start
if key < arr[mid]:

end = mid - 1
else:

start = mid + 1
n = len(arr)
idx = start % n
return arr[idx]


","- Initialize the start and end indices to the first and last index of the array.
- In the while loop, calculate the mid index using the formula (end - start)//2 + start.
- Compare the key with the element at the mid index.
- If the key is less than the element at mid index, update the end index to mid - 1.
- If the key is greater than or equal to the element at mid index, update the start index to mid + 1.
- Finally, calculate the actual index by taking the modulus of start index with the length of the array."
57,C) fast & slow pointers,2. LinkedList find_cycle_start.py,"
class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

def find_cycle_start(head):

cycle_exist = False
slow, fast = head, head
while fast and fast.next:
fast = fast.next.next
slow = slow.next
if slow == fast:
cycle_exist = True
break


if not cycle_exist:
return -1
cycle_length = 1
fixed = slow
slow = slow.next
while fixed != slow and slow:
cycle_length = cycle_length + 1
slow = slow.next


p1, p2 = head, head
while cycle_length > 0:
p2 = p2.next
cycle_length = cycle_length - 1


while p1 != p2:
p1 = p1.next
p2 = p2.next

return p1

if __name__ == ""__main__"":
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = Node(6)

head.next.next.next.next.next.next = head.next.next

head.next.next.next.next.next.next = head.next.next.next

head.next.next.next.next.next.next = head

head.next.next.next.next.next.next = head.next.next.next.next.next
","The most important step to remember in this algorithm is the Floyd's Tortoise and Hare algorithm to detect the cycle in the linked list:

```
slow, fast = head, head

while fast and fast.next:
    fast = fast.next.next
    slow = slow.next
    if slow == fast:
        cycle_exist = True
        break
```

This step is crucial as it determines whether a cycle exists in the linked list or not. If a cycle exists, it also identifies the position where the cycle starts."
58,C) fast & slow pointers,6. Rearrange a LinkedList (medium).py,"
import copy

class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

def summarize(self):
l = []
tail = self
while tail:
l.append(tail.value)
tail = tail.next
l.append(None)

return l



def create_linked_list(lst):

lst.pop()
if len(lst) < 2:
return Node(lst[0])
head = Node(lst[0])
tail = Node(lst[1])
head.next = tail
for i in lst[2:]:
tail.next = Node(i)
tail = tail.next
tail.next = None
_ = head.summarize()
return head

def reverse(node):
prev = None
cnt = 0
while node:
next = node.next
node.next = prev
prev = node
node = next
cnt = cnt + 1
_ = prev.summarize()
return prev, cnt

def insert_node(prev_node, new_node):

if prev_node is None:
raise Exception(""List is empty"")

new_node.next = prev_node.next

prev_node.next = new_node


def reorder(head):
rtail, ll_len = reverse(copy.deepcopy(head))
c2 = 1
tail = head
while ll_len > c2:




tmp = tail.next
tail.next = rtail
rtail = tmp
tail = tail.next


c2 = c2 + 1

tail.next = None

return head.summarize()



if __name__ == ""__main__"":
ll = create_linked_list([2, 4, 6, 8, 10, 12, None])
ll = create_linked_list([2, 4, 6, 8, 10, None])
","- The most important step in this algorithm is the ""reorder"" function that reorders the linked list by reversing the second half and then inserting the reversed nodes after each node in the first half of the list."
59,C) fast & slow pointers,1. LinkedList Cycle (easy).py,"

class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next


def has_cycle(head, return_node = False):
slow, fast = head, head
while fast and fast.next:
slow = slow.next
fast = fast.next.next
if slow == fast:
if return_node:
return True, slow
return True
if return_node:
return False, slow
return False


def cycle_length(head):
cycle_bool, slow = has_cycle(head, True)
if not cycle_bool:
return cnt
cnt = 1
fixed = slow
slow = slow.next
while fixed != slow and slow:
slow = slow.next
cnt = cnt + 1
return cnt

if __name__ == ""__main__"":
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = Node(6)


head.next.next.next.next.next.next = head.next.next


head.next.next.next.next.next.next = head.next.next.next","The most important step to remember in this algorithm is to use the two-pointer technique to detect a cycle in the linked list. This is done by iterating through the linked list with two pointers: slow and fast. The slow pointer moves one node at a time, while the fast pointer moves two nodes at a time. If there is a cycle in the linked list, the slow and fast pointers will eventually meet."
60,C) fast & slow pointers,4. Middle of the LinkedList (easy).py,"
class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next


def create_linked_list(tail_val):

if tail_val <= 2:
return 1
head, tail = Node(1), Node(2)
head.next = tail
for i in range(3, tail_val+1):
tail.next = Node(i)
tail = tail.next
tail.next = None
return head

def find_middle_of_linked_list(head):
slow, fast = head, head
while fast and fast.next:
slow = slow.next
fast = fast.next.next
return slow.value

if __name__ == ""__main__"":
ll = create_linked_list(3)
ll = create_linked_list(5)
ll = create_linked_list(6)
ll = create_linked_list(7)
","1. The most important step to remember is to use the `create_linked_list` function to create a linked list by passing in the value of the tail node. This function will create a linked list of consecutive numbers starting from 1 as the head and the specified value as the tail.

2. Another important step is to use the `find_middle_of_linked_list` function to find the middle value of the linked list. This function uses the ""slow and fast"" pointer technique to find the middle node of the linked list."
61,C) fast & slow pointers,3. Hapy Number.py,"
class Node:
def __init__(self, v, n = None):
self.value = v
self.next = n
self.sum_squares = sum(int(i)**2 for i in str(self.value))

def has_cycle(self):
slow, fast = self, self
while fast and fast.next:
fast = fast.next.next
slow = slow.next
if slow and fast and slow.value == fast.value:
return True
return False

def find_happy_number(num):
head = Node(num)
tail = Node(head.sum_squares)
head.next = tail
while not head.has_cycle():
if tail.sum_squares == 1:
return True
tail.next = Node(tail.sum_squares)
tail = tail.next
return False

if __name__ == ""__main__"":
","- The most important step to remember is the calculation of the sum of squares of the digits of a number. This is done in the `sum_squares` method in the `Node` class.
- Another important step is the detection of a cycle in the linked list. This is done in the `has_cycle` method in the `Node` class."
62,C) fast & slow pointers,3B. Hapy Number Faster.py,"
def find_happy_number(num):
slow = sum(int(i)**2 for i in str(num))
fast = sum(int(i)**2 for i in str(slow))
while slow != fast:
if slow == 1 or fast == 1:
return True
slow = sum(int(i)**2 for i in str(slow))
fast =  sum(int(i)**2 for i in str(sum(int(i)**2 for i in str(fast))))
return False

if __name__ == ""__main__"":
","- The most important step to remember is to calculate the sum of the squares of the digits of a number. This is done using `sum(int(i)**2 for i in str(num))`. It is used multiple times in the algorithm to calculate the next number in the sequence.

- Another important step is to use two pointers, `slow` and `fast`, to iterate through the sequence of numbers. The `slow` pointer progresses one step at a time, while the `fast` pointer progresses two steps at a time. They are updated using the same calculation for the sum of squares of their digits.

- The condition `while slow != fast` is also important, as it checks for the presence of a cycle in the sequence. If a cycle is found, then the number is not a happy number. If either `slow` or `fast` becomes 1, then the number is a happy number and the algorithm terminates."
63,C) fast & slow pointers,5. Palindrome LinkedList (medium).py,"
import copy

class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next


def create_linked_list(lst):

if len(lst) < 2:
return Node(lst[0])
head = Node(lst[0])
tail = Node(lst[1])
head.next = tail
for i in lst[2:]:
tail.next = Node(i)
tail = tail.next
tail.next = None
return head

def reverse(node):
prev = None
while node:
next = node.next
node.next = prev
prev = node
node = next
return prev


def is_palondrome(head):
if not head or not head.next:
return False


slow, fast = head, head
while fast and fast.next:
slow = slow.next
fast = fast.next.next


if fast is None:
return False


head_second_half = reverse(copy.deepcopy(slow))

while head and head_second_half:
if head.value != head_second_half.value:
return False
head = head.next
head_second_half = head_second_half.next

return True




if __name__ == ""__main__"":
ll = create_linked_list([2,4,6,4,2])
ll = create_linked_list([2,4,6,8,6,4,2])
ll = create_linked_list([2,4,6,4,2,2])
","The most important step to remember in this algorithm is the `reverse` function, which is used to reverse the second half of the linked list."
64,R) MISC,merge_sort.py,"def merge_sort(arr):
if len(arr) <= 1:
return arr

mid = len(arr) // 2
left = arr[:mid]
right = arr[mid:]

left = merge_sort(left)
right = merge_sort(right)

return merge(left, right)

def merge(left, right):
result = []
left_idx, right_idx = 0, 0


while left_idx < len(left) and right_idx < len(right):
if left[left_idx] < right[right_idx]:
result.append(left[left_idx])
left_idx += 1
else:
result.append(right[right_idx])
right_idx += 1


while left_idx < len(left):
result.append(left[left_idx])
left_idx += 1


while right_idx < len(right):
result.append(right[right_idx])
right_idx += 1

return result



","- The most important step to remember is to recursively divide the input array in half until the base case of having subarrays of length 1 is reached.
- Another important step is merging the sorted subarrays in the correct order by comparing the elements from each subarray and appending them to the result array."
65,R) MISC,670. Maximum Swap.py,"
def max_swap(nums):

num_lst = list(str(nums))

last_oc_map = {num : i for i, num in enumerate(num_lst)}

for i, num in enumerate(num_lst):
for dig in range(9, int(num), -1):
if last_oc_map.get(dig):
idx = last_oc_map.get(dig)
num_lst[i], num_lst[idx] = num_lst[idx], num_lst[i]
return int(''.join(num_lst))
return int(''.join(num_lst))
","- Convert the given number into a list of its digits
- Create a dictionary that maps each digit to its last occurrence in the list
- Iterate over each digit in the list
- For each digit, iterate from 9 down to the digit itself
- If a larger digit is found in the dictionary, swap the current digit with the larger digit
- Return the integer value of the updated list of digits"
66,R) MISC,stacks_adj_str.py,"
def remove_duplicates(string):

stack = []

for char in string:


if stack and stack[-1] == char:

stack.pop()
else:

stack.append(char)


return """".join(stack)

","- Initialize a stack (an empty list) to store unique characters from the string.
- Iterate through each character in the string.
- If the stack is not empty and the top of the stack is the same as the current character, remove the top element from the stack.
- Otherwise, add the current character to the stack.
- Finally, join the elements in the stack and return the resulting string without duplicates."
67,R) MISC,49. Group Anograms.py,"

def group(strs):

d={}
for s in strs:
sorted_s = ''.join(sorted(s))
if sorted_s in d:
d[sorted_s].append(s)
else:
d[sorted_s] = [s]
return list(d.values())
","- The most important step of this algorithm is to create a dictionary (d) to store the sorted strings as keys and the original strings as values.
- Another important step is to iterate through the input list of strings (strs) and sort each string (sorted_s) before checking if it is already in the dictionary. If it is, append the original string to the corresponding value list in the dictionary. If it is not, create a new key-value pair in the dictionary with the sorted string as the key and the original string as the value.
- Lastly, return the values of the dictionary as a list."
68,R) MISC,stacks_calculator.py,"def calculator(expression):
number = 0
sign_value = 1
result = 0
operations_stack = []

for c in expression:
if c.isdigit():
number = number * 10 + int(c)
elif c in ""+-"":
result += number * sign_value
sign_value = -1 if c == '-' else 1
number = 0
elif c == '(':
operations_stack.append(result)
operations_stack.append(sign_value)
result = 0
sign_value = 1
elif c == ')':
result += sign_value * number
pop_sign_value = operations_stack.pop()
result *= pop_sign_value

second_value = operations_stack.pop()
result += second_value
number = 0

return result + number * sign_value
","- The most important step to remember in this algorithm is the use of a stack to handle nested parentheses. The algorithm pushes the current result and sign value onto the stack when encountering an opening parenthesis and pops them off the stack when encountering a closing parenthesis. This ensures that the innermost parentheses are evaluated first.
- Another important step to remember is the accumulation of numbers and applying the appropriate sign value when encountering a plus or minus sign. The algorithm multiplies the number by the current sign value and adds it to the result. This allows for the proper evaluation of the arithmetic expressions."
69,R) MISC,1249. Minimum Remove to Make Valid Parentheses.py,"

def pars(string):
str_lst = list(string)
stack = []
for i, s in enumerate(string):
if s == '(':
stack.append(i)
elif s ==')':
if stack:
stack.pop()
else:
str_lst[i] = ''
while stack:
idx = stack.pop()
str_lst[idx] = ''

return ''.join(str_lst)
","1. The most important step in this algorithm is to use a stack to keep track of the indices of open parentheses. When encountering an open parenthesis, push its index onto the stack. When encountering a closing parenthesis, check if the stack is empty. If it is not empty, pop an index from the stack and set the character at that index to an empty string. Repeat this process until the stack is empty.
2. Another important step is to convert the list of characters back into a string using the ''.join() method before returning the result."
70,R) MISC,50_POW.py,"

def pow(x, n):
if n < 0:
x = 1 / x
n = -n
result = 1
while n:
if n % 2 == 1:
result = result * x
n -= 1
else:
x = (x * x)
n = n/2
return result
","- If `n` is negative, `x` should be inverted and `n` should be made positive. 
- Inside the while loop, if `n` is odd, `result` should be multiplied by `x`.
- Inside the while loop, if `n` is even, `x` should be squared and `n` should be divided by 2."
71,R) MISC,121_best_time_to_buy_stock.py,"

def max_prof(arr):
max_prof = 0
if len(arr) <= 1:
return max_prof
left, right = 0, 1

while right <= len(arr) - 1:
if arr[left] >= arr[right]:
left = right
right += 1
else:
curr_prof = arr[right] - arr[left]
max_prof = max(max_prof,curr_prof)
right += 1
return max_prof
","1. Set the initial maximum profit to zero.
2. Check if the length of the input array is less than or equal to one, and return the maximum profit if it is.
3. Initialize the pointers `left` and `right` to index 0 and 1, respectively.
4. Enter a loop until the `right` pointer is less than or equal to the last index of the array.
5. Check if the value at the `left` pointer is greater than or equal to the value at the `right` pointer.
   - If true, update the `left` pointer to the `right` pointer and increment the `right` pointer.
   - If false, calculate the current profit, update the maximum profit if the current profit is greater than the existing maximum profit, and increment the `right` pointer.
6. Return the maximum profit."
72,R) MISC,rotational_cipher.py,"

def rotationalCipher(input, rotationFactor):

output = ''
for char in input:
if not char.isalnum():
ord_adj = ord(char)
elif char.isdigit():
ord_adj = ord(char) - ord('0')
ord_adj = ord_adj + rotationFactor
ord_adj = ord_adj % 10
ord_adj = ord_adj + ord('0')
elif char.isupper():
ord_adj = ord(char) - ord('A')
ord_adj = ord_adj + rotationFactor
ord_adj = ord_adj % 26
ord_adj = ord_adj + ord('A')
else:
ord_adj = ord(char) - ord('a')
ord_adj = ord_adj + rotationFactor
ord_adj = ord_adj % 26
ord_adj = ord_adj + ord('a')

output = output + chr(ord_adj)

return output


","- The most important step is to determine the adjustment value (ord_adj) for each character based on its type (alphanumeric, digit, uppercase letter, or lowercase letter) and the rotation factor. This adjustment value is essential in calculating the rotated character's ASCII code.
- Another important step is to update the output string by appending the rotated character (chr(ord_adj)) to it."
73,R) MISC,matrix0.py,"

def set_matrix_zeros(mat):
rows = len(mat)
cols = len(mat[0])

row_set = set()
col_set = set()
for row in range(rows):
for col in range(cols):
if mat[row][col] == 0:
row_set.add(row)
col_set.add(col)

for row in range(rows):
for col in range(cols):
if row in row_set or col in col_set:
mat[row][col] = 0

return mat

m1_input = [[1,2,3],[4,5,6],[7,0,9]]
m1_output = [[1, 0, 3], [4, 0, 6], [0, 0, 0]]
m2_input = [[1,2,3,4],[4,5,6,7],[8,9,4,6]]
m2_output = [[1, 2, 3, 4], [4, 5, 6, 7], [8, 9, 4, 6]]
m3_input = [[1,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,0,1,1,1],[1,1,1,1,1]]
m3_output = [[0, 0, 0, 0, 0], [1, 0, 0, 1, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 0, 1, 1]]
","- The important step to remember in this algorithm is to identify the rows and columns that contain at least one zero and store their indices in separate sets (row_set and col_set).
- The next important step is to iterate through the matrix again and set the values of the elements in rows and columns present in the row_set and col_set to zero.
- This ensures that all elements in the identified rows and columns are set to zero."
74,R) MISC,1091. Shortest Path in Binary Matrix.py,"
from collections import deque
def shortest_path(grid):
n = len(grid)
directions = [
(0,1),
(1,1),
(1,0),
(1,-1),
(0, -1),
(-1, -1),
(-1, 0),
(-1, 1),
]
if grid[0][0] == 1 or grid[n-1][n-1] == 1:
return -1
queue = deque()
queue.append((0,0,1))
grid[0][0] = 1
while queue:
(row, col, path_len) = queue.popleft()
if row == n-1 and col == n-1:
return path_len
for row_adj, col_adj in directions:
new_row, new_col = row + row_adj, col + col_adj
valid_move = 0 <= new_row < n and 0 <= new_col < n
if valid_move and grid[new_row][new_col] == 0:
queue.append((new_row, new_col, path_len + 1))
return -1

","- The most important step to remember in this algorithm is to use a queue to perform a breadth-first search (BFS) traversal through the grid. This is done by initializing a deque and adding the starting position to the queue. 
- Another important step is to mark the starting position as visited by setting its value in the grid to 1. This prevents revisiting the starting position in future iterations."
75,R) MISC,71. Simplify Path.py,"

def cpath(path):

path = path.split(""/"")
stack = []
for i in path:
if i == "".."":
if stack:
stack.pop()
elif i not in {""."",""""}:
stack.append(i)
conoical_path = ""/"" + ""/"".join(stack)
return conoical_path

","- Split the given path using the ""/"" delimiter.
- Initialize an empty stack.
- Iterate through each element in the split path.
  - If the element is "".."" and the stack is not empty, pop the top element from the stack.
  - Otherwise, if the element is not ""."" or an empty string, push it onto the stack.
- Create a canonical path by joining the elements in the stack with ""/"" delimiter, and prepend ""/"" to it.
- Return the canonical path."
76,R) MISC,matrix_rotation.py,"

def rotate_image(matrix):

rows, cols = len(matrix), len(matrix[0])
mat2 = [[0 for _ in range(cols)] for _ in range(rows)]
for r in range(rows):
for c in range(cols):
d_row = (rows - 1) - r
mat2[c][r] = matrix[d_row][c]
return mat2

m1_input = [[6, 9], [2, 7]]
m1_output = [[2, 6], [7, 9]]
m2_input = [[1]]
m2_output = [[1]]
m3_input = [[2, 14, 8], [12, 7, 14], [3, 3, 7]]
m3_output = [[3, 12, 2], [3, 7, 14], [7, 14, 8]]
","The most important step of this algorithm to remember is how the indices are being swapped to perform the rotation:

mat2[c][r] = matrix[d_row][c]

This step is responsible for rotating the elements of the matrix and should be understood and remembered."
77,R) MISC,backtracking.py,"

def word_search(grid, word):
n = len(grid)
m = len(grid[0])
for row in range(n):
for col in range(m):
if depth_first_search(row, col, word, grid):
return True
return False


def depth_first_search(row, col, word, grid):
if len(word) == 0:
return True

c1 = row < 0
c2 = row == len(grid)
c3 = col < 0
c4 = col == len(grid[0])
c5 = grid[row][col].lower() != word[0].lower()
if any([c1,c2,c3,c4,c5]):
return False

grid[row][col] = '*'

for rowOffset, colOffset in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
if depth_first_search(row + rowOffset, col + colOffset, word[1:], grid):
return True

grid[row][col] = word[0]

return False


ex1 = [
[""N"",""W"",""L"",""I"",""M""],
[""V"",""I"",""L"",""Q"",""O""],
[""O"",""L"",""A"",""T"",""O""],
[""R"",""T"",""A"",""I"",""N""],
[""O"",""I"",""T"",""N"",""C""]
]
ex2 = [
[""J"",""D"",""E"",""I"",""Y""],
[""G"",""I"",""L"",""M"",""O""],
[""Z"",""A"",""I"",""E"",""O""],
[""L"",""T"",""B"",""S"",""N""],
[""S"",""I"",""T"",""C"",""C""]
]
ex3 = [
[""H"",""D"",""L"",""I"",""M""],
[""R"",""I"",""L"",""Z"",""O""],
[""W"",""B"",""A"",""E"",""O""],
[""H"",""U"",""K"",""V"",""N""],
[""S"",""Y"",""E"",""D"",""C""]
]",The most important step to remember in this algorithm is the depth-first search function.
78,R) MISC,13_roman_to_int.py,"
def roman_to_int(roman):
out = 0
mapp = {
'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M': 1000,
'IV': 4, 'IX': 9, 'XL': 40, 'XC':90, 'CD': 400, 'CM': 900
}
for i in range(len(roman)):
char1 = roman[i]
if i == 0:
out += mapp[char1]
continue
char2 = roman[i-1]
if (char2 + char1) in mapp:
out -= mapp[char2]
out += mapp[char2 + char1]
else:
out += mapp[char1]
return out
","1. Create a dictionary `mapp` that maps each Roman numeral to its corresponding integer value.
2. Iterate through each character of the input Roman numeral (`roman`) using a for loop.
3. If it is the first character (i.e., `i == 0`), add its corresponding integer value to the `out` variable.
4. If it is not the first character, check if the combination of current character (`char1`) and the previous character (`char2`) exists in the `mapp` dictionary.
5. If the combination exists, subtract the integer value of `char2` from `out` and add the integer value of the combination (`char2 + char1`) to `out`.
6. If the combination doesn't exist, simply add the integer value of `char1` to `out`.
7. Finally, return the accumulated value of `out` as the result of the Roman numeral conversion."
79,J) Subsets,practice.py,"from collections import deque
def find_subsets(nums):




subsets = [[]]
for num in nums:
for i in range(len(subsets)):
subset = list(subsets[i])
subset.append(num)
subsets.append(subset)
return subsets

def find_subsets_dups(nums):










nums.sort()
subsets = [[]]
start, end = 0,0
for i in range(len(nums)):
start = 0
if i > 0 and nums[i] == nums[i-1]:
start = end
end = len(subsets)
for j in range(start, end):
subset = list(subsets[j])
subset.append(nums[i])
subsets.append(subset)
return subsets

def find_permutations(nums):







result = []
perms = deque()
perms.append([])
for i in range(len(nums)):
for _ in range(len(perms)):
subset = perms.popleft()
for j in range(len(subset)+1):
sub_copy = list(subset)
sub_copy.insert(j, nums[i])
if len(sub_copy) == len(nums):
result.append(sub_copy)
else:
perms.append(sub_copy)
return result







permutations = [s]
for i in range(len(s)):
if s[i].isnumeric():
continue
for j in range(len(permutations)):
perm = list(permutations[j])
perm[i] = perm[i].swapcase()
permutations.append(''.join(perm))
return permutations

def find_letter_case_string_permutations(s):






perms = [s]
for i in range(len(s)):
if s[i].isnumeric():
continue
for j in range(len(perms)):
perm = list(perms[j])
perm[i] = perm[i].swapcase()
perms.append(''.join(perm))
return perms


[], [1], [3], [1,3],[3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]
]

[5,3,1],
[3,5,1],
[3,1,5],
[5,1,3],
[1,5,3],
[1,3,5]
]

""ad52"", ""Ad52"", ""aD52"", ""AD52""
]
""ab7c"", ""Ab7c"", ""aB7c"", ""AB7c"", ""ab7C"", ""Ab7C"", ""aB7C"", ""AB7C""
]
","1. In the first algorithm (find_subsets), the most important step to remember is to iterate through each number in the input list and for each number, iterate through the current subsets. Then, create a new subset by appending the current number to each subset, and add this new subset to the subsets list.

2. In the second algorithm (find_subsets_dups), the most important step to remember is to handle duplicates by sorting the input list, keeping track of the start and end indexes of subsets that have the same number as the previous number. Then, create new subsets by appending the current number only to the subsets within the range of start to end.

3. In the third algorithm (find_permutations), the most important step to remember is to use a deque to store the current permutations. For each number in the input list, iterate through each existing permutation and insert the current number at different positions. If the length of the new permutation matches the length of the input list, add it to the result list. Otherwise, add it back to the deque for further iterations.

4. In the fourth algorithm (find_letter_case_string_permutations), the most important step to remember is to iterate through each character in the input string and for each character, iterate through the current permutations. Then, swap the case of the current character and add the resulting permutation to the list of permutations."
80,J) Subsets,1. Subsets.py,"

def find_subsets(nums):
subsets = []
subsets.append([])
for num in nums:
for i in range(len(subsets)):
subset = list(subsets[i])
subset.append(num)
subsets.append(subset)
return subsets
","1. Initialize an empty list called `subsets` to store the subsets.
2. Add an empty list to `subsets` as the first subset.
3. Iterate over each number in `nums`.
4. Iterate over each subset in `subsets`.
5. Create a new subset by copying the current subset and appending the current number.
6. Add the new subset to `subsets`.
7. Return the `subsets` list."
81,J) Subsets,3. Permutations.py,"

from collections import deque

def find_permutations(nums):
result = []
permutations = deque()
permutations.append([])
for i in range(len(nums)):
for _ in range(len(permutations)):

permutation_A = permutations.popleft()

for j in range(len(permutation_A) + 1):
permutation_B = list(permutation_A)
permutation_B.insert(j, nums[i])
if len(permutation_B) == len(nums):
result.append(permutation_B)
else:
permutations.append(permutation_B)
return result

[5,3,1],
[3,5,1],
[3,1,5],
[5,1,3],
[1,5,3],
[1,3,5]
]
",The most important step to remember in this algorithm is to use a deque (double-ended queue) to store the permutations.
82,J) Subsets,2. Subset Dups.py,"

def find_subsets(nums):
nums.sort()
subsets = [[]]
for i in range(len(nums)):
start = 0
if i > 0 and nums[i] == nums[i-1]:
start = end
end = len(subsets)
for j in range(start, end):
subset = list(subsets[j])
subset.append(nums[i])
subsets.append(subset)
return subsets


[], [1], [3], [1,3],[3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]
]

","- The most important step to remember is to sort the input array `nums` before generating the subsets. This ensures that duplicate numbers will be placed next to each other, making it easier to handle them in the algorithm.

- Another important step is to keep track of the `start` and `end` indices in the nested loop. These indices help in avoiding duplicates by only considering subsets from the previous level if the current number is the same as the previous number."
83,J) Subsets,4. String Permutations.py,"

def find_letter_case_string_permutations(s):
permutations = [s]
for i in range(len(s)):
if s[i].isnumeric():
continue
for j in range(len(permutations)):
perm = list(permutations[j])
perm[i] = perm[i].swapcase()
permutations.append(''.join(perm))
return permutations

""ad52"", ""Ad52"", ""aD52"", ""AD52""
]
""ab7c"", ""Ab7c"", ""aB7c"", ""AB7c"", ""ab7C"", ""Ab7C"", ""aB7C"", ""AB7C""
]
","- The most important step in this algorithm is to iterate through each character in the input string (step 4).
- Another important step is to swap the case of the character at the current index (step 7)."
138,O) Knapsack ,dijkstra.py,"
def find_lowest_cost_node(costs, processed_nodes):
lowest_cost = float('inf')
lowest_cost_node = None
for node, cost in costs.items():
if cost < lowest_cost and node not in processed_nodes:
lowest_cost = cost
lowest_cost_node = node
return lowest_cost_node



graph = {'start': {'a': 6, 'b': 2},
'a': {'fin': 1},
'b': {'a': 3, 'fin': 5},
'fin': {}}

costs = {'a': 6, 'b': 2, 'fin': float('inf')}

parents = {'a' : 'start', 'b' : 'start', 'fin' : None}

processed = []


node = find_lowest_cost_node(costs, processed)
while node:
cost = costs[node]
neighbors = graph[node]
for n in neighbors.keys():
new_cost = cost + neighbors[n]
if costs[n] > new_cost:
costs[n] = new_cost
parents[n] = node
processed.append(node)
node = find_lowest_cost_node(costs, processed)
",The most important step to remember in this algorithm is finding the node with the lowest cost. This is crucial for determining the next node to visit and updating the cost and parent for each neighbor node.
139,O) Knapsack ,01 Knapsack done Internal.py,"

def solve_knapsack(profits, weights, capacity):
ROWS = len(profits)
COLUMNS = capacity + 1
if len(profits) != len(weights) or capacity < 1:
return 0


dp = [[0 for _ in range(COLUMNS)] for _ in range(ROWS)]


for c in range(COLUMNS):
if c >= weights[0]:
dp[0][c] = profits[0]



for i in range(1, ROWS):

for c in range(1, COLUMNS):
profit1, profit2 = 0, 0
if c >= weights[i]:
profit1 = profits[i] + dp[i - 1][c - weights[i]]
profit2 = dp[i - 1][c]

dp[i][c] = max(profit1, profit2)


return dp[ROWS-1][COLUMNS-1]

","1. Creating the dynamic programming table (`dp`) is an important step to remember. This table is used to store the maximum profit that can be achieved for each item and capacity combination.

2. The calculation of `profit1` and `profit2` is important to determine the maximum profit at each cell of the dynamic programming table. `profit1` represents the profit if the current item is chosen, while `profit2` represents the profit if the current item is not chosen.

3. The use of `max(profit1, profit2)` to determine the maximum profit for each cell in the dynamic programming table is crucial in order to correctly calculate the maximum profit for the overall knapsack problem.

4. Returning `dp[ROWS-1][COLUMNS-1]` at the end of the algorithm is important as it represents the maximum profit that can be achieved with the given profits, weights, and capacity."
140,O) Knapsack ,3 Subset Sum (medium).py,"

def can_partition(num, zsum):
COLUMNS = zsum + 1
ROWS = len(num)
dp = [[False for _ in range(COLUMNS)] for _ in range(ROWS)]


for row in range(ROWS):
dp[row][0] = True


for zsum in range(COLUMNS):
if zsum == num[0]:
dp[0][zsum] = True



for row in range(1, ROWS):
for zsum in range(1, COLUMNS):

if dp[row - 1][zsum]:
dp[row][zsum] = True

elif zsum >= num[row]:
dp[row][zsum] = dp[row - 1][zsum - num[row]]

return dp[ROWS-1][COLUMNS-1]


can_partition([1, 2, 3, 7], 6) == True
can_partition([1, 2, 7, 1, 5], 10) == True
can_partition([1, 3, 4, 8], 6) == False
","- The most important step of this algorithm is to initialize the first row of the dp table with True for the column representing 0 sum. This indicates that it is possible to achieve a sum of 0 by not selecting any elements from the array.
- Another important step is to check if the current sum (zsum) is equal to the value of the first element in the array. If it is, then mark dp[0][zsum] as True. This is necessary to handle the case where there is only one element in the array and its value matches the desired sum.
- Additionally, the nested loops that iterate through the rows and columns of the dp table are crucial for filling in the values. The value dp[row][zsum] is determined by the value in dp[row-1][zsum] or dp[row-1][zsum-num[row]] depending on whether we include the current element or not."
141,O) Knapsack ,practice.py,"

def solve_knapsack(profits, weights, capacity):



R_PROFIT = len(profits)
C_CAPACITY = capacity + 1
if len(profits) != len(weights):
return 0



dp = [[0 for _ in range(C_CAPACITY)] for _ in range(R_PROFIT)]
for c_cap in range(C_CAPACITY):
if c_cap >= weights[0]:
dp[0][c_cap] = profits[0]










for r_prof in range(1, R_PROFIT):
for c_cap in range(1, C_CAPACITY):
profit1, profit2 = 0,0
if c_cap >= weights[r_prof]:
profit1 = profits[r_prof] + dp[r_prof - 1][c_cap - weights[r_prof]]
profit2 = dp[r_prof - 1][c_cap]
dp[r_prof][c_cap] = max(profit1, profit2)



return dp[R_PROFIT -1][C_CAPACITY -1]
","The most important step to remember in this algorithm is the calculation of the maximum profit for each cell in the dp matrix:

```python
dp[r_prof][c_cap] = max(profit1, profit2)
```

This step determines the maximum profit based on whether the current item is included in the knapsack or not. It considers the previous row in the dp matrix, taking into account the weight of the current item and the capacity of the knapsack.

It is also important to remember the initialization of the first row of the dp matrix:

```python
dp[0][c_cap] = profits[0]
```

This initializes the maximum profit for the first item when considering different capacities of the knapsack."
142,O) Knapsack ,1A - Brute Force :  Knapsack (medium).py,"

def solve_knapsack(profits, weights, capacity):
return knapsack_recursive(profits, weights, capacity, 0, '')


def knapsack_recursive(profits, weights, capacity, currentIndex, logger):
logger = logger + ' ->'

if capacity <= 0 or currentIndex >= len(profits):
return 0



profit1 = 0
if weights[currentIndex] <= capacity:
profit1 = profits[currentIndex] + knapsack_recursive(
profits, weights, capacity - weights[currentIndex], currentIndex + 1, logger)


profit2 = knapsack_recursive(profits, weights, capacity, currentIndex + 1, logger)

return max(profit1, profit2)


","The most important step to remember in this algorithm is using the ""max"" function to return the maximum profit between profit1 and profit2."
143,O) Knapsack ,2 Equal Subset Sum Partition.py,"

def can_partition(num):
s = sum(num)

if s % 2 != 0:
return False


s = int(s / 2)
COLUMNS = s + 1
ROWS = len(num)

dp = [[False for x in range(COLUMNS)] for y in range(ROWS)]


for i in range(0, ROWS):
dp[i][0] = True



for j in range(1, COLUMNS):
if num[0] == j:
dp[0][j] = True


for i in range(1, ROWS):
for zsum in range(1, COLUMNS):

if dp[i - 1][zsum]:
dp[i][zsum] = True
elif zsum >= num[i]:
dp[i][zsum] = dp[i - 1][zsum - num[i]]


return dp[ROWS - 1][COLUMNS - 1]


can_partition([1, 2, 3, 4]) == True
can_partition([1, 1, 3, 4, 7]) ==  True
can_partition([2, 3, 4, 6]) == False","1. The most important step to remember is to check if the sum of the input array is even (line 5). If it is not, then it is not possible to partition the array into two equal subsets, so the algorithm should return False immediately.

2. Another important step to remember is initializing the dynamic programming (dp) table (line 9). The dp table is used to store the results of subproblems, and it needs to be initialized correctly for the algorithm to work properly.

3. Finally, it is important to understand the logic of updating the dp table in the nested for loop (lines 18-22). The algorithm checks if the subset with a sum of ""zsum"" is possible without including the current element ""num[i]"", and if it is, it marks it as True in the dp table. This step is crucial for finding the solution and determining if a partition is possible.

Note: It is important to also understand the overall logic of the algorithm, which is to find if it is possible to partition the input array into two subsets with equal sums using dynamic programming."
144,O) Knapsack ,1B - Memoization :  Knapsack (medium).py,"

def solve_knapsack(profits, weights, capacity):

dp = [[-1 for x in range(capacity+1)] for y in range(len(profits))]
return knapsack_recursive(dp, profits, weights, capacity, 0, '')


def knapsack_recursive(dp, profits, weights, capacity, currentIndex, logger):
logger = logger + ' ->'

if capacity <= 0 or currentIndex >= len(profits):
return 0


if dp[currentIndex][capacity] != -1:
return dp[currentIndex][capacity]



profit1 = 0
if weights[currentIndex] <= capacity:
profit1 = profits[currentIndex] + knapsack_recursive(
dp, profits, weights, capacity - weights[currentIndex], currentIndex + 1, logger)


profit2 = knapsack_recursive(dp, profits, weights, capacity, currentIndex + 1, logger)

profit = max(profit1, profit2)
dp[currentIndex][capacity] = profit
return profit


","- Initialize the `dp` array to store the results of subproblems and avoid redundant calculations.
- Use a recursive helper function to solve the knapsack problem by considering two choices at each step: including the current item or excluding it."
145,O) Knapsack ,1E SuperFast Algo - Single Array.py,"
def solve_knapsack(profits, weights, capacity):

n = len(profits)
if capacity <= 0 or n == 0 or len(weights) != n:
return 0

dp = [0 for x in range(capacity+1)]


for c in range(0, capacity+1):
if weights[0] <= c:
dp[c] = profits[0]


for i in range(1, n):
for c in range(capacity, -1, -1):
profit1, profit2 = 0, 0

if weights[i] <= c:
profit1 = profits[i] + dp[c - weights[i]]

profit2 = dp[c]

dp[c] = max(profit1, profit2)

return dp[capacity]



","The most important step to remember in this algorithm is the nested loops that iterate over the profits, weights, and capacity. Specifically, the loop that iterates over the items (i) and the loop that iterates over the capacity (c). These loops are responsible for calculating and updating the maximum profit (dp[c]) that can be achieved for each capacity."
146,O) Knapsack ,1D SuperFast Algo.py,"
def solve_knapsack(profits, weights, capacity):

n = len(profits)
if capacity <= 0 or n == 0 or len(weights) != n:
return 0




dp = [[0 for x in range(capacity+1)] for y in range(2)]


for c in range(0, capacity+1):
if weights[0] <= c:
dp[0][c] = dp[1][c] = profits[0]


for i in range(1, n):
for c in range(0, capacity+1):
profit1, profit2 = 0, 0

if weights[i] <= c:
profit1 = profits[i] + dp[(i - 1) % 2][c - weights[i]]

profit2 = dp[(i - 1) % 2][c]

dp[i % 2][c] = max(profit1, profit2)

return dp[(n - 1) % 2][capacity]



","- Check if capacity is greater than 0, n is greater than 0, and the length of weights is equal to n.
- Set up the dp (dynamic programming) table with appropriate dimensions.
- Iterate through the capacity range.
- Check if the weight of the current item is less than or equal to the current capacity.
- Calculate the profit if the current item is included in the knapsack (profit1).
- Calculate the profit if the current item is not included in the knapsack (profit2).
- Update the dp table with the maximum profit.
- Return the maximum profit from the dp table."
147,O) Knapsack ,1C - Dynamic :  Knapsack (medium).py,"

def solve_knapsack(profits, weights, capacity):

n = len(profits)
if capacity <= 0 or n == 0 or len(weights) != n:
return 0

dp = [[0 for x in range(capacity+1)] for y in range(n)]


for i in range(0, n):
dp[i][0] = 0


for c in range(0, capacity+1):
if weights[0] <= c:
dp[0][c] = profits[0]


for i in range(1, n):
for c in range(1, capacity+1):
profit1, profit2 = 0, 0

if weights[i] <= c:

profit1 = profits[i] + dp[i - 1][c - weights[i]]

profit2 = dp[i - 1][c]

dp[i][c] = max(profit1, profit2)


return dp[n - 1][capacity]


","- Ensure that the capacity is greater than 0 and the length of weights and profits are equal to n (length of the items) to avoid errors.
- Use a 2D array dp to store the maximum profits for different subproblems."
148,A) sliding-window,5. Repeated DNA.py,"

def subseq(s,k):
start = 0
input_set = set()
output_set = set()
for end in range(k, len(s), 1):
if s[start:end] in input_set:
output_set.add(s[start:end])
else:
input_set.add(s[start:end])
start += 1
formatting_output = list(output_set)
formatting_output.sort()
return formatting_output

outlst = [""CCCCCCCTTT"", ""CCCCCCTTTT"", ""CCCCCTTTTT"", ""CCCCTTTTTT"", ""TCCCCCCCTT"",
""TTCCCCCCCT"", ""TTTCCCCCCC"", ""TTTTCCCCCC"", ""TTTTTCCCCC""]
","- Initialize a start variable to 0.
- Create two empty sets, input_set and output_set.
- Iterate over the range from k to the length of s, incrementing by 1.
- Check if the substring from start to end of s is in the input_set.
- If it is, add it to the output_set.
- If it is not, add it to the input_set.
- Increment the start variable by 1.
- Convert the output_set to a list, sort it, and assign it to formatting_output.
- Return formatting_output."
149,A) sliding-window,7. sliding freq str.py,"def compare_dicts(dict1, dict2):
if set(dict1.keys()) == set(dict2.keys()):
for key in dict1:
if dict2[key] < dict1[key]:
return False
return True
else:
return False


def min_window(s, t):
left = 0
freq = {}
t_freq = {}
for ch in t:
t_freq[ch] = t_freq.get(ch,0) + 1
min_substr = s
for right in range(len(s)):
if s[right] in t_freq:
freq[s[right]] = freq.get(s[right],0) + 1
while compare_dicts(t_freq, freq):
if len(min_substr) > len(s[left:right + 1]):
min_substr = s[left:right + 1]
if s[left] in freq:
v = freq.get(s[left],0)
v = max(0, v-1)
freq[s[left]] = v
left += 1
return min_substr


","- In the `compare_dicts` function, the most important step is to compare the keys of `dict1` and `dict2` using the `set()` function. This ensures that both dictionaries have the same keys before proceeding with the comparison.

- In the `min_window` function, the most important step is the `compare_dicts(t_freq, freq)` check within the `while` loop. This check ensures that the frequency of characters in the current substring (`freq`) matches the desired frequency (`t_freq`) of characters from `t`."
150,A) sliding-window,3. Longest Substring with maximum K Distinct Characters (medium).py,"

def main(s,k):
window_start, largest_sub_array = 0, 0
for window_end in range(len(s)):
substr = s[window_start:window_end]
while len(set(substr)) == k and window_start < window_end:
largest_sub_array = max(largest_sub_array, window_end - window_start + 1)
window_start = window_start + 1
substr = s[window_start:window_end]
return largest_sub_array if largest_sub_array != 0 else len(s)





",The most important step to remember in this algorithm is to update the largest_sub_array variable by comparing it with the current subarray length (window_end - window_start + 1) in each iteration.
151,A) sliding-window,4. Fruits into Baskets (medium).py,"

def main(s,k=2):
window_start, largest_sub_array = 0, 0
for window_end in range(len(s)):
sub = s[window_start:window_end + 1]
while len(sub) > k and window_start < window_end:
if len(set(sub)) == 2:
largest_sub_array = max(largest_sub_array, window_end - window_start + 1)
break
window_start = window_start + 1
sub = s[window_start:window_end + 1]
return largest_sub_array




","The most important step to remember in this algorithm is to iterate through the input string `s` using two pointers (`window_start` and `window_end`) to define a sliding window. The window is expanded by incrementing `window_end` and shrunk by incrementing `window_start`.

When the length of the substring within the window exceeds `k`, the algorithm checks if the number of unique characters in the substring is equal to `k`. If it is, the algorithm updates the `largest_sub_array` if the current window size is larger.

In summary, the most important step to remember is the sliding window approach and the condition to check `len(set(sub)) == 2` when the length of the substring exceeds `k`."
152,A) sliding-window,2. smallest_subset_given_sum_easy.py,"

def main(l,s):
window_sum, window_start  = 0, 0
smallest_sub_array = len(l)
for window_end in range(len(l)):
window_sum = window_sum + l[window_end]
while window_sum >= s:
smallest_sub_array = min(smallest_sub_array, window_end - window_start + 1)
window_sum = window_sum - l[window_start]
window_start = window_start + 1
return smallest_sub_array





","- Initialize variables `window_sum` and `window_start` to 0.
- Initialize variable `smallest_sub_array` to the length of the list `l`.
- Insert each element of the list into `window_sum` and update `window_start` and `window_end` accordingly.
- Keep track of the smallest subarray length that has a sum greater than or equal to `s`.
- Subtract the value at `window_start` from `window_sum` and increment `window_start`.
- Return the smallest subarray length found."
153,A) sliding-window,1. max_sub_array_of_size_k.py,"

def max_sub_array_of_size_k(k, arr):
window_sum, highest_window = 0,0
for i in range(len(arr)):
window_sum = window_sum + arr[i]
if i < (k - 1):
continue
if window_sum > highest_window:
highest_window = window_sum
window_sum = window_sum - arr[i-(k - 1)]
return highest_window

","- Keep track of the current sum of the window (window_sum).
- Keep track of the highest window sum encountered so far (highest_window).
- Update the window sum by adding the current element and subtracting the element that is no longer in the window (arr[i-(k-1)]).
- Compare the window sum with the highest window sum and update it if necessary."
154,A) sliding-window,13_roman_to_int.py,"
def roman_to_int(roman):
out = 0
mapp = {
'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M': 1000,
'IV': 4, 'IX': 9, 'XL': 40, 'XC':90, 'CD': 400, 'CM': 900
}
for i in range(len(roman)):
char1 = roman[i]
if i == 0:
out += mapp[char1]
continue
char2 = roman[i-1]
if (char2 + char1) in mapp:
out -= mapp[char2]
out += mapp[char2 + char1]
else:
out += mapp[char1]
return out
","-The most important step of this algorithm to remember is to iterate through each character of the input roman numeral. 
-Another important step is to check if the current character and the previous character form a valid combination of two Roman numerals (e.g., IV, IX, etc.) and update the total accordingly."
155,A) sliding-window,6 Array String.py,"

def product_except(arr):
tot_product = 1
for n in arr:
tot_product = tot_product * n
new_arr = [tot_product / n for n in arr]
return new_arr


","- The most important step to remember is to calculate the total product of all the numbers in the input array. 
- Another important step is to divide the total product by each number in the array to get the new array."
156,F) In-place Reversal of a LinkedList,234_palindrome_linked_list.py,"

class ListNode:
def __init__(self, val=0, next=None):
self.val = val
self.next = next

def is_palindrome(head):
m1, end = head, head
while end and end.next:
end = end.next.next
m1 = m1.next

cur = m1
cur = cur.next
prev = m1
while cur:
cur.next, prev, cur = prev, cur, cur.next


tail = prev
while head != tail:
if head.val != tail.val:
return False
if head == m1 or tail == m1:
return False
head = head.next
tail = tail.next
return True



r = ListNode('r')
a1 = ListNode('a')
c1 = ListNode('c')
e = ListNode('e')
c2 = ListNode('c')
a2 = ListNode('a')
r2 = ListNode('r')

r.next = a1
a1.next = c1
c1.next = e
e.next = c2
c2.next = a2
a2.next = r2


r = ListNode('r')
a1 = ListNode('a')
c1 = ListNode('c')
e1 = ListNode('e')
e2 = ListNode('e')
c2 = ListNode('c')
a2 = ListNode('a')
r2 = ListNode('r')

r.next = a1
a1.next = c1
c1.next = e1
e1.next = e2
e2.next = c2
c2.next = a2
a2.next = r2","- The most important step to remember is reversing the second half of the linked list.
- Another important step is comparing the values of the nodes in the first half of the list with the reversed nodes in the second half to check for palindrome."
157,F) In-place Reversal of a LinkedList,5. Reverse Alternating List.py,"class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

temp = self
while temp is not None:
temp = temp.next

def reorder_list(head):
if not head:
return head

curr = fast = head
while fast and fast.next:
curr = curr.next
fast = fast.next.next

prev = None
while curr:
curr.next, prev, curr = prev, curr, curr.next

first, second = head, prev
while second.next:
first.next, first = second, first.next
second.next, second = first, second.next

return head


head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = Node(6)
head.next.next.next.next.next.next = Node(7)
head.next.next.next.next.next.next.next = Node(8)

result = reorder_list(head)
","The most important step to remember in this algorithm is:
- The reversing of the second half of the list (the part starting from `prev`, `curr`) using a while loop.

Additionally, it is important to remember:
- The traversal of the list with two pointers (`curr` and `fast`) to find the middle of the list.
- The swapping of nodes to reorder the list in-place."
158,F) In-place Reversal of a LinkedList,4. Reverse alternating K-element Sub-list (medium).py,"


class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

temp = self
while temp is not None:
temp = temp.next

def reverse_alternate_k_elements(head, k):
if k <= 1:
return head

current, previous = head, None
SWITCH = True
while current:
p_previous = previous
p_current = current
nxt = None
i = 0
if SWITCH:
while current and i < k:
nxt = current.next
current.next = previous
previous = current
current = nxt
i = i + 1

if p_previous:
p_previous.next = previous
else:
head = previous

p_current.next = current

previous = p_current
else:
while current and i < k:
previous = current
current = current.next
i = i + 1
SWITCH = not SWITCH

return head

head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = Node(6)
head.next.next.next.next.next.next = Node(7)
head.next.next.next.next.next.next.next = Node(8)

result = reverse_alternate_k_elements(head, 2)
",The most important step of this algorithm to remember is the actual reversal of the k elements. This is done by iterating over the k elements and updating the next pointers to reverse their order.
159,F) In-place Reversal of a LinkedList,3. Reverse every K-element Sub-list (medium).py,"


class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

temp = self
while temp is not None:
temp = temp.next

def reverse_every_k_elements(head, k):
if k <= 1:
return head

current, previous = head, None
while current:
p_previous = previous
p_current = current
nxt = None
i = 0
while current and i < k:
nxt = current.next
current.next = previous
previous = current
current = nxt
i = i + 1

if p_previous:
p_previous.next = previous
else:
head = previous

p_current.next = current

previous = p_current

return head

head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = Node(6)
head.next.next.next.next.next.next = Node(7)
head.next.next.next.next.next.next.next = Node(8)

result = reverse_every_k_elements(head, 3)
","The most important steps to remember in this algorithm are:
1. Initializing the variables `current`, `previous`, `p_previous`, `p_current`, `nxt`, `i` outside of the loops to keep track of the nodes during the reversal process.
2. Reversing the linked list in groups of `k` elements by modifying the `next` pointers of the nodes. 
3. Updating the `next` pointers of the nodes correctly to maintain the connections between the reversed groups."
160,F) In-place Reversal of a LinkedList,2. Reverse a sub linked list (medium).py,"

from copy import deepcopy

class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

temp = self
while temp is not None:
temp = temp.next


def reverse_sub_list(head, p, q):
if p == q:
return head
current, previous = head, None
i = 0

while current and i < p -1:
previous = current
current = current.next
i = i + 1


p_previous = previous
p_current = current



nxt = None
i = 0
while current and i < q - p + 1:
nxt = current.next
current.next = previous
previous = current
current = nxt
i = i + 1

if p_previous:

p_previous.next = previous
else:

head = previous


p_current.next = current



return head


head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)

result = reverse_sub_list(head,2,4)","- The algorithm recursively reverses a sublist within a linked list, given the starting and ending positions (p and q). 
- The algorithm keeps track of the previous node and the current node during traversal to reverse the sublist."
161,F) In-place Reversal of a LinkedList,1. Reverse Linked LIst (easy).py,"


class Node:
def __init__(self, value, next=None):
self.value = value
self.next = next

temp = self
while temp is not None:
temp = temp.next


def reverse(head):
current, previous, next = head, None, None
while current:
next = current.next
current.next = previous
previous = current
current = next
return previous


head = Node(2)
head.next = Node(4)
head.next.next = Node(6)
head.next.next.next = Node(8)
head.next.next.next.next = Node(10)

result = reverse(head)","- The most important step of this algorithm is the reverse function, which reverses the linked list. It uses the current, previous, and next pointers to iterate through the list and reverse the connections between the nodes.
- Another important step is setting up the initial linked list by creating node instances and connecting them with the next pointers. This is done in the code block starting with `head = Node(2)` and continuing with the `head.next = Node(4)`, `head.next.next = Node(6)`, etc. lines."
162,P) Topological Sort (Graph),4. Compilation Tasks.py,"

from collections import deque

def find_compilation_order(edges):
lst, graph, in_degree = [], {}, {}
if not edges:
return lst


for edge in edges:
[child, parent] = edge
if parent not in graph:
graph[parent] = []
graph[parent].append(child)
else:
graph[parent].append(child)
in_degree[child] = in_degree.get(child,0) + 1

source = deque()
for vert, ins in in_degree.items():
if ins == 0:
source.append(vert)

while source:
vert = source.popleft()
lst.append(vert)
for child in graph[vert]:
in_degree[child] -= 1
if in_degree[child] == 0:
source.append(child)

return lst

find_compilation_order([['A', 'B'], ['B', 'C'], ['A', 'D']]) == ['C','B','D','A']
find_compilation_order([['A', 'B'], ['B', 'C'], ['C', 'D']]) == ['D', 'C', 'B', 'A']","- Create an empty list called ""lst"" to store the compilation order
- Create an empty dictionary called ""graph"" to represent the graph
- Create an empty dictionary called ""in_degree"" to store the in-degree of each vertex
- Iterate over each edge in the given list of edges
- - Extract the child and parent from the current edge
- - If the parent is not already in the graph dictionary:
- - - Create a new entry in the graph dictionary for the parent
- - - Append the child to the parent's list of children in the graph dictionary
- - Else:
- - - Append the child to the parent's list of children in the graph dictionary
- - Update the in-degree of the child by incrementing it by 1 (using the get() method to handle the case when the child is not in the dictionary)
- Create a deque called ""source"" to store the vertices with in-degree 0
- Iterate over the items in the in_degree dictionary
- - If the in-degree of a vertex is 0, append the vertex to the source deque
- While the source deque is not empty:
- - Pop a vertex from the left of the source deque and append it to the ""lst"" list
- - Iterate over the children of the popped vertex in the graph dictionary
- - - Decrement the in-degree of each child by 1
- - - If the in-degree becomes 0, append the child to the source deque
- Return the ""lst"" list"
163,P) Topological Sort (Graph),2. Tasks Scheduling (medium).py,"
from collections import deque


def is_scheduling_possible(tasks, prerequisites):
scheduled_tasks = []
if tasks <= 0:
return True


graph = {i: [] for i in range(tasks)}
cnt_incoming = {i : 0 for i in range(tasks)}


for prereq in prerequisites:
parent, child = prereq
graph[parent].append(child)
cnt_incoming[child] += 1



sources = deque()
for node, incoming in cnt_incoming.items():
if incoming == 0:
sources.append(node)



while sources:
node = sources.popleft()
scheduled_tasks.append(node)
for child_node in graph[node]:
cnt_incoming[child_node] -= 1
if cnt_incoming[child_node] == 0:
sources.append(child_node)

return len(scheduled_tasks) == tasks

","- The most important step in this algorithm is to create a graph to represent the dependencies between tasks and keep track of the number of incoming edges for each task.
- Another important step is to identify the sources (tasks with no incoming edges) and enqueue them in a queue.
- Lastly, while there are sources in the queue, dequeuing a source, scheduling it, and reducing the incoming edges of its children. If a child's incoming edges become 0, it becomes a new source and is added to the queue."
164,P) Topological Sort (Graph),practice.py,"

def solve_knapsack(profits, weights, capacity):



R_PROFIT = len(profits)
C_CAPACITY = capacity + 1
if len(profits) != len(weights):
return 0



dp = [[0 for _ in range(C_CAPACITY)] for _ in range(R_PROFIT)]
for c_cap in range(C_CAPACITY):
if c_cap >= weights[0]:
dp[0][c_cap] = profits[0]










for r_prof in range(1, R_PROFIT):
for c_cap in range(1, C_CAPACITY):
profit1, profit2 = 0,0
if c_cap >= weights[r_prof]:
profit1 = profits[r_prof] + dp[r_prof - 1][c_cap - weights[r_prof]]
profit2 = dp[r_prof - 1][c_cap]
dp[r_prof][c_cap] = max(profit1, profit2)



return dp[R_PROFIT -1][C_CAPACITY -1]
","- The most important step of this algorithm to remember is to initialize the dynamic programming array `dp` with appropriate dimensions and set the base cases correctly in the first loop.
- Another important step to remember is the nested loop that fills the `dp` array using the recurrence relation to find the maximum profit."
165,P) Topological Sort (Graph),3. Tasks Scheduling Order (medium).py,"
from collections import deque


def is_scheduling_possible(tasks, prerequisites):
scheduled_tasks = []
if tasks <= 0:
return scheduled_tasks


graph = {i: [] for i in range(tasks)}
cnt_incoming = {i : 0 for i in range(tasks)}


for prereq in prerequisites:
parent, child = prereq
graph[parent].append(child)
cnt_incoming[child] += 1



sources = deque()
for node, incoming in cnt_incoming.items():
if incoming == 0:
sources.append(node)



while sources:
node = sources.popleft()
scheduled_tasks.append(node)
for child_node in graph[node]:
cnt_incoming[child_node] -= 1
if cnt_incoming[child_node] == 0:
sources.append(child_node)

return scheduled_tasks

","- Creating an empty list `scheduled_tasks` to store the scheduled tasks
- Checking if the number of tasks is greater than 0, as it is a necessary condition for scheduling the tasks
- Creating an empty dictionary `graph` to store the dependencies between tasks
- Creating an empty dictionary `cnt_incoming` to store the number of incoming edges for each task
- Building the dependency graph by iterating through the `prerequisites` list and updating the `graph` and `cnt_incoming` dictionaries accordingly
- Creating a queue called `sources` and adding all tasks with no incoming edges (i.e., tasks with an incoming count of 0) to it
- Running a while loop while the `sources` queue is not empty
- Removing a task from the left of the `sources` queue and adding it to the `scheduled_tasks` list
- Decreasing the incoming count of all the children of the current task by 1
- If the incoming count of a child becomes 0, adding it to the `sources` queue
- Returning the `scheduled_tasks` list as the result of the scheduling algorithm"
166,P) Topological Sort (Graph),1. Topological Sort (medium).py,"

from collections import deque


def topological_sort(vertices, edges):
sortedOrder = []
if vertices <= 0:
return sortedOrder


inDegree = {i: 0 for i in range(vertices)}
graph = {i: [] for i in range(vertices)}


for edge in edges:
parent, child = edge[0], edge[1]
graph[parent].append(child)
inDegree[child] += 1



sources = deque()
for key in inDegree:
if inDegree[key] == 0:
sources.append(key)



while sources:
vertex = sources.popleft()
sortedOrder.append(vertex)
for child in graph[vertex]:
inDegree[child] -= 1
if inDegree[child] == 0:
sources.append(child)


if len(sortedOrder) != vertices:
return []

return sortedOrder


[3, 2], [3, 0], [2, 0], [2, 1]
]) == [3, 2, 0, 1]
[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]
]) == [4, 2, 3, 0, 1]
[6, 4], [6, 2], [5, 3], [5, 4], [3, 0], [3, 1], [3, 2], [4, 1]
]) == [5, 6, 3, 4, 0, 2, 1]","The most important step to remember in this algorithm is to create the inDegree dictionary, which tracks the number of incoming edges for each vertex. This is important for identifying the sources (vertices with no incoming edges) and for decrementing the inDegree when removing edges from the graph."
5665,E) Cycle Sort,4. Find the Duplicate Number (easy).py,"

def find_duplicate(nums):

i, n = 0, len(nums)
while i < n:
if (i + 1) != nums[i]:
first_idx = nums[i]
if first_idx == nums[first_idx - 1]:
return first_idx
else:
second_idx = nums[first_idx - 1]
nums[i] = second_idx
nums[first_idx - 1] = first_idx
else:
i = i + 1
return -1

","- The most important step to remember is to swap the elements at the current index and the index of the element that should be at that position (nums[i] and nums[first_idx - 1]).
- Another important step is to check if the element at the current index is equal to the element that should be at that index (first_idx == nums[first_idx - 1]). This helps in identifying the duplicate element."
5666,E) Cycle Sort,5. Find All Duplicate Numbers.py,"

def find_duplicate(nums):
i, n = 0, len(nums)
dups = set()
while i < n:
if i + 1 != nums[i]:
first_idx = nums[i]
if first_idx == nums[first_idx - 1]:
dups.add(first_idx)
i = i + 1
continue
else:
second_idx = nums[first_idx - 1]
nums[i] = second_idx
nums[first_idx - 1] = first_idx
else:
i = i + 1
return dups

",The most important step to remember in this algorithm is to swap the elements at the indices `first_idx-1` and `i` if `first_idx` is equal to `nums[first_idx-1]`.
5667,E) Cycle Sort,6. Find the Corrupt Pair (easy).py,"

def find_corrupt_numbers(nums):
i, n = 0, len(nums)
dups = set()
while i < n:
if i + 1 != nums[i]:
first_idx = nums[i]
if first_idx == nums[first_idx - 1]:
dups.add(first_idx)
i = i + 1
continue
else:
second_idx = nums[first_idx - 1]
nums[i] = second_idx
nums[first_idx - 1] = first_idx
else:
i = i + 1

missing = set()
for i in range(n):
if i+1 != nums[i]:
missing.add(i+1)
return dups | missing


","- The most important step is to identify and keep track of any duplicate numbers in the given list. This is done by utilizing the `dups` set to store the duplicate numbers found.
- Another important step is to find and store any missing numbers in the given list. This is achieved by using the `missing` set to store the numbers that are not found in their correct index."
5668,E) Cycle Sort,practice.py,"def cyclic_sort(nums):

i = 0

while i < len(nums):


p1 = nums[i]

p2 = nums[p1-1]

nums[i] = p2

nums[p1-1] = p1


if (i+1) == p2:
i += 1
return nums


def find_missing_number(nums):


i, n = 0, len(nums)


while i < n:

p1_value = nums[i]

if p1_value < n and nums[p1_value] != p1_value:




p2_value = nums[p1_value]
nums[i] = p2_value
nums[p1_value] = p1_value
else:

i += 1

for i in range(n):
if i != nums[i]:
return i
return 0

def find_missing_numbers(nums):

i, n = 0, len(nums)

while i < n:

p1_val = nums[i]

if p1_val < (n+1) and p1_val != nums[p1_val-1]:
p2_val = nums[p1_val-1]
nums[i] = p2_val
nums[p1_val-1] = p1_val

else:
i += 1

l = [i+1 for i in range(n) if (i+1)!=nums[i]]
return l

def find_duplicate(nums):

i, n = 0, len(nums)

dups = set()

while i < n:

if i+1 != nums[i]:

p1_val = nums[i]


if p1_val == nums[p1_val - 1]:

dups.add(p1_val)
i += 1

else:
p2_val = nums[p1_val - 1]
nums[i] = p2_val
nums[p1_val - 1] = p1_val

else:
i += 1

return dups




","- The most important step in the cyclic_sort function is swapping the current number with the number at its correct index.
- In the find_missing_number function, the important step is swapping the current number with the number at its correct index if it is not equal to its index.
- In the find_missing_numbers function, the important step is swapping the current number with the number at its correct index if it is not equal to its index+1.
- The most important step in the find_duplicate function is finding and collecting all the duplicate numbers."
5669,E) Cycle Sort,2. Find the Missing Number (easy).py,"

def find_missing_number(nums):
i, n = 0, len(nums)
while i < n:
p1_val = nums[i]
if p1_val < n and p1_val != nums[p1_val]:
p2_val = nums[p1_val]
nums[i] = p2_val
nums[p1_val] = p1_val
else:
i += 1
for i in range(n):
if i != nums[i]:
return i
return n

","- The most important step to remember in this algorithm is the swapping of elements.
- Another important step is the condition `i != nums[i]` in the final loop."
5670,E) Cycle Sort,1. Cyclic Sort (easy).py,"

def cyclic_sort(nums):
i = 0
while i < len(nums):
p1 = nums[i]
p2 = nums[p1 - 1]
nums[i] = p2
nums[p1 - 1] = p1
if (i + 1) == p2:
i += 1
return nums

","The most important step of this algorithm to remember is to swap the elements if they are not in their correct position. Specifically, swapping the current element at index i with the element at index p1 - 1."
5671,E) Cycle Sort,3. Find all Missing Numbers (easy).py,"

def find_missing_numbers(nums):
i, n = 0, len(nums)
while i < n:
first_idx = nums[i]
if first_idx <= n and first_idx != nums[first_idx - 1]:
second_idx = nums[first_idx - 1]
nums[i] = second_idx
nums[first_idx - 1] = first_idx
else:
i = i + 1
l = []
for i in range(n):
if i+1 != nums[i]:
l.append(i+1)
return l

","- The algorithm swaps the first index with the number at that index. This is an important step to ensure that each number is at its correct position in the list.
- The algorithm checks if the current number is not equal to the number at its correct position. If they are not equal, then that current number is a missing number."
5672,D) Merge Intervals,3. Intervals Intersection (medium).py,"

class Interval:
def __init__(self, values) -> None:
s, e = values
self.start = s
self.end = e

def interval_to_list(interval_list):
return [[i.start, i.end] for i in interval_list]

def list_to_interval(lst):
interval_list = []
for values in lst:
interval_list.append(Interval(values))
return interval_list


def merge(intervalsA, intervalsB):
merged = []
a,b = 0,0
while b < len(intervalsB) and a < len(intervalsA):

if intervalsA[a].end < intervalsB[b].start or intervalsB[b].end < intervalsA[a].start:
pass
else:
start = max(intervalsA[a].start, intervalsB[b].start)
end = min(intervalsA[a].end, intervalsB[b].end)
merged.append(Interval([start,end]))
if intervalsB[b].end == intervalsA[a].end:
a = a + 1
b = b + 1
elif intervalsB[b].end < intervalsA[a].end:
b = b + 1
else:
a = a + 1
return interval_to_list(merged)

B = list_to_interval([[1, 3], [5, 6], [7, 9]])
A = list_to_interval([[2, 3], [5, 7]])

B = list_to_interval([[1, 3], [5, 7], [9, 12]])
A = list_to_interval([[5, 10]])

","The most important step to remember in this algorithm is the merging of intervals. This is done by comparing the end and start values of the intervals and determining if they overlap. If they do overlap, the merged interval is created by taking the maximum start value and the minimum end value."
5673,D) Merge Intervals,2 Insert Interval (medium).py,"

class Interval:
def __init__(self, values) -> None:
s, e = values
self.start = s
self.end = e

def interval_to_list(interval_list):
return [[i.start, i.end] for i in interval_list]

def list_to_interval(lst):
interval_list = []
for values in lst:
interval_list.append(Interval(values))
return interval_list


def insert_interval(intervals, new_interval):
merged = []
intervals.sort(key = lambda x: x.start)
i = 0

while i < len(intervals) and intervals[i].end < new_interval.start:
merged.append(intervals[i])
i = i + 1


while i < len(intervals) and intervals[i].start <= new_interval.end:
new_interval.end = max(new_interval.end, intervals[i].end)
new_interval.start = min(new_interval.start, intervals[i].start)
i = i + 1


merged.append(new_interval)


while i < len(intervals):
merged.append(intervals[i])
i = i + 1

return interval_to_list(merged)

interval_list = list_to_interval([[1,3], [5,7], [8,12]])
to_insert = Interval([4,6])

interval_list = list_to_interval([[1,3], [5,7], [8,12]])
to_insert = Interval([4,10])

interval_list = list_to_interval([[2,3],[5,7]])
to_insert = Interval([1,4])","- The algorithm sorts the intervals in ascending order based on their start values using the `intervals.sort()` method. This step is important as it ensures that the intervals are processed in the correct order.
- The algorithm merges the new interval with existing intervals by iterating through the intervals list and comparing their start and end values. This step is crucial for determining the correct placement and merging of the new interval."
5674,D) Merge Intervals,1B. Merge Intervals (medium) list.py,"

def merge(intervals):
merged = []

intervals.sort(key = lambda x: x[0])
if len(intervals) < 2:
return intervals
Astart, Aend = intervals.pop(0)
for Bstart, Bend in intervals:
if Bstart <= Aend:
Aend = max(Aend,Bend)
else:
merged.append([Astart, Aend])
Astart = Bstart
Aend = Bend
merged.append([Astart, Aend])
return merged

","- Sort the intervals in ascending order based on the start value (key = lambda x: x[0]).
- If the length of the intervals is less than 2, return intervals.
- Pop the first interval and assign its start and end values to Astart and Aend respectively.
- Iterate through the remaining intervals:
   - If the start value of the current interval is less than or equal to Aend, update Aend to the maximum of Aend and Bend.
   - Otherwise, append [Astart, Aend] to the merged list, update Astart and Aend to the start and end values of the current interval, and continue.
- Finally, append [Astart, Aend] to the merged list (since the last interval may not have been appended inside the loop).
- Return the merged list."
5675,D) Merge Intervals,1. Merge Intervals (medium).py,"

class Interval:
def __init__(self, start, end):
self.start = start
self.end = end

return ""["" + str(self.start) + "", "" + str(self.end) + ""]""


def merge(intervals):
merged = []

intervals.sort(key = lambda x: x.start)
if len(intervals) < 2:
return intervals
for i, B in enumerate(intervals):
if i == 0:
A = B
continue
if B.start > A.end:
merged.append(A)
A = B
else:
min_start = min(B.start, A.start)
max_end = max(B.end, A.end)
A = Interval(min_start, max_end)
merged.append(A)
return merged

def main():
s=''
for i in merge([Interval(1, 4), Interval(2, 5), Interval(7, 9)]):

s=''
for i in merge([Interval(6, 7), Interval(2, 4), Interval(5, 9)]):

s=''
for i in merge([Interval(1, 4), Interval(2, 6), Interval(3, 5)]):

main()","- The most important step in this algorithm is to sort the intervals based on their start values. This is done using the `intervals.sort(key = lambda x: x.start)` line.
- Another important step is to iterate through the intervals and check if the current interval overlaps with the previous one. If it does, then the current interval is merged with the previous one by updating the start and end values."
5676,D) Merge Intervals,4. conflicting appointments (medium).py,"

class Interval:
def __init__(self, values) -> None:
s, e = values
self.start = s
self.end = e

def interval_to_list(interval_list):
return [[i.start, i.end] for i in interval_list]

def list_to_interval(lst):
interval_list = []
for values in lst:
interval_list.append(Interval(values))
return interval_list


def can_attend_all_appointments(X):
X.sort(key = lambda x: x.start)
left = 0
right = len(X) -1
while left < right:

if not (X[left].end < X[right].start or X[left].end < X[right].start):
return False
if X[right].end >= X[left].end:
right = right - 1
else:
left = left + 1
return True

X = list_to_interval([[1,4], [2,5], [7,9]])

X = list_to_interval([[6,7], [2,4], [8,12]])

X = list_to_interval([[4,5], [2,3], [3,6]])

",The most important step to remember in this algorithm is the sorting of the intervals before checking for any overlaps.
5677,I) Two Heaps,1. Find the Median of a Number Stream (medium).py,"
from heapq import *


class MedianOfAStream:

maxHeap = []
minHeap = []

def insert_num(self, num):
if not self.maxHeap or -self.maxHeap[0] >= num:
heappush(self.maxHeap, -num)
else:
heappush(self.minHeap, num)



if len(self.maxHeap) > len(self.minHeap) + 1:
heappush(self.minHeap, -heappop(self.maxHeap))
elif len(self.maxHeap) < len(self.minHeap):
heappush(self.maxHeap, -heappop(self.minHeap))

def find_median(self):
if len(self.maxHeap) == len(self.minHeap):

return -self.maxHeap[0] / 2.0 + self.minHeap[0] / 2.0


return -self.maxHeap[0] / 1.0


medianOfAStream = MedianOfAStream()
medianOfAStream.insert_num(3)
medianOfAStream.insert_num(1)
medianOfAStream.insert_num(5)
medianOfAStream.insert_num(4)
","The most important step to remember in this algorithm is to compare the current number with the top element of the maxHeap. If the current number is smaller or equal, then push it into the maxHeap. Otherwise, push it into the minHeap. Also, remember to balance the heaps so that the size difference between the maxHeap and minHeap is at most 1."
5678,I) Two Heaps,practice.py,"
from heapq import *

class MedianOfAStream:
minheap = []
maxheap = []

def insert_num(self,num):

if len(self.maxheap) == 0:
heappush(self.maxheap, -num)

elif -self.maxheap[0] >= num:
heappush(self.maxheap, -num)

else:
heappush(self.minheap, num)







if len(self.maxheap) > len(self.minheap) +1:
tmp_num = -heappop(self.maxheap)
heappush(self.minheap, tmp_num)
elif len(self.maxheap) < len(self.minheap):
tmp_num = heappop(self.minheap)
heappush(self.maxheap, -tmp_num)

def find_median(self):

if len(self.maxheap) == len(self.minheap):
return (-self.maxheap[0] + self.minheap[0]) / 2.0
else:

return -self.maxheap[0]


medianOfAStream = MedianOfAStream()
medianOfAStream.insert_num(3)
medianOfAStream.insert_num(1)
medianOfAStream.insert_num(5)
medianOfAStream.insert_num(4)","- The most important step to remember is to correctly insert a number into the data structure. This involves comparing the number to the current elements in the maxheap and minheap and deciding which heap to insert it into.
- Another important step is to rebalance the heaps if they become imbalanced. This is done in the `insert_num` method by checking the lengths of the maxheap and minheap and ensuring that their sizes do not differ by more than one.
- Finally, to find the median, it is important to correctly calculate the median based on the lengths and elements in the maxheap and minheap."
5679,M) Top K,8. K closest numbers (medium).py,"

from heapq import heappush, heappop

def find_closest_elements(nums, K, X):

min_heap = []
for num in nums:
val = (abs(num - X), num)
heappush(min_heap, val)



result = []
for _ in range(K):
(dist, num) = heappop(min_heap)
result.append(num)
return sorted(result)
","- Use the `heappush` function from the `heapq` module to insert elements into the min heap.
- Use the `heappop` function from the `heapq` module to remove the element with the smallest distance from the min heap.
- Use the `abs` function to calculate the absolute difference between each number in the list and the target number."
5680,M) Top K,1. Top K numbers (easy).py,"

from heapq import heappush, heappop


def find_k_largest_numbers(nums, k):
min_heap = []
for i in range(k):
heappush(min_heap, nums[i])

for i in range(k, len(nums)):
if nums[i] > min_heap[0]:
heappop(min_heap)
heappush(min_heap, nums[i])

return sorted(list(min_heap))



","- The most important step is to initialize the `min_heap` with the first `k` numbers from `nums` using `heappush`.
- Another important step is to iterate from `k` to the end of `nums` and compare each number with the smallest element in `min_heap` using `heappop` and `heappush`."
5681,M) Top K,practice.py,"from heapq import heappush, heappop

def find_k_largest_numbers(nums, k):




min_heap = []
for i, num in enumerate(nums):
if i < k:
heappush(min_heap, num)
elif num > min_heap[0]:
heappop(min_heap)
heappush(min_heap, num)
return sorted(list(min_heap))

def find_kth_smallest_numbers(nums, k):







max_heap = []
for i, num in enumerate(nums):
if i < k:
heappush(max_heap, -num)
elif num < -max_heap[0]:
heappop(max_heap)
heappush(max_heap, -num)
return -max_heap[0]

def find_k_freq_nums(nums, k):




counter = {}
for num in nums:
counter[num] = counter.get(num,0) + 1

min_heap = []
for num, count in counter.items():
heappush(min_heap, (count,num))
if len(min_heap) > k:
heappop(min_heap)

return sorted([l[1] for l in list(min_heap)])

def find_k_frequent_letters(letters):


m = {}
for letter in letters:
m[letter] = m.get(letter,0) + 1


max_heap = []
for letter, count in m.items():
heappush(max_heap, (-count, letter))

sorted_letters = []
for _ in list(max_heap):
letter = heappop(max_heap)
for _ in range(abs(letter[0])):
sorted_letters.append(letter[1])

return ''.join(sorted_letters)

def find_closest_elements(nums, K, X):

max_heap = []
for i, num in enumerate(nums):
dist_num_tuple = (-abs(num - X), num)
heappush(max_heap, dist_num_tuple)
if i >= K:
heappop(max_heap)
return sorted([dist_tuple[1] for dist_tuple in max_heap])




","- In the `find_k_largest_numbers` function, the most important step to remember is to use a min heap to keep track of the k largest numbers. This can be done by using the `heappush` and `heappop` functions from the heapq library.
- In the `find_kth_smallest_numbers` function, the most important step to remember is to use a max heap to keep track of the k smallest numbers. This can be done by multiplying the numbers by -1 and using the `heappush` and `heappop` functions from the heapq library.
- In the `find_k_freq_nums` function, the most important step to remember is to use a min heap to keep track of the k most frequent numbers. This can be done by using a tuple of (frequency, number) and the `heappush` and `heappop` functions from the heapq library.
- In the `find_k_frequent_letters` function, the most important step to remember is to use a max heap to keep track of the k most frequent letters. This can be done by using a tuple of (-frequency, letter) and the `heappush` and `heappop` functions from the heapq library.
- In the `find_closest_elements` function, the most important step to remember is to use a max heap to keep track of the K closest elements to X. This can be done by using a tuple of (-abs(num - X), num) and the `heappush` and `heappop` functions from the heapq library."
5682,M) Top K,2. Kth Smallest Number (easy).py,"

from heapq import heappush, heappop

MULT = -1


def find_k_largest_numbers(nums, k):
min_heap = []
for i in range(k):
heappush(min_heap, MULT*nums[i])

for i in range(k, len(nums)):
if MULT*nums[i] > min_heap[0]:
heappop(min_heap)
heappush(min_heap, MULT*nums[i])

return MULT*min_heap[0]



","- The most important step to remember in this algorithm is to use a min heap to keep track of the k largest numbers.
- Another important step to remember is to multiply the numbers by -1 before pushing them into the min heap in order to turn it into a max heap."
5683,M) Top K,6. Frequency Sort (medium).py,"

from heapq import heappush, heappop

def find_k_frequent_numbers(letters):


m = {}
for letter in letters:
m[letter] = m.get(letter,0) + 1


max_heap = []
for letter, count in m.items():
heappush(max_heap, (-count, letter))



sorted_letters = []
for _ in list(max_heap):
letter = heappop(max_heap)
for _ in range(abs(letter[0])):
sorted_letters.append(letter[1])

return ''.join(sorted_letters)





","- Use a dictionary to count the frequency of each letter in the input 
- Use a max heap to store the letters and their respective counts, with the count as the key 
- Pop elements from the max heap and append the letter to the sorted_letters list 
- Return the sorted_letters list as a string"
5684,M) Top K,10 Sum of Elements (medium).py,"

from heapq import heappush, heappop

def find_sum_of_elements(nums, k1, k2):

min_heap = []
for num in nums:
heappush(min_heap, num)


for _ in range(k1):
heappop(min_heap)


return sum(heappop(min_heap) for _ in range(k2 - k1 - 1))

","- Import the heappush and heappop functions from the heapq module
- Use heappush to push each element from the nums list onto the min_heap 
- Use a for loop to heappop the min_heap k1 times, discarding the smallest k1 elements 
- Use a list comprehension and another for loop to heappop the min_heap k2 - k1 - 1 times, summing up these elements"
5685,M) Top K,5. Frequent Numbers (medium).py,"

from heapq import heappush, heappop

def find_k_frequent_numbers(nums, k):

m = {}
for num in nums:
m[num] = m.get(num,0) + 1



min_heap = []
for num,counter in m.items():
heappush(min_heap, (counter,num))
if len(min_heap) > k:
heappop(min_heap)



return sorted([l[1] for l in list(min_heap)])



","- Count the frequency of each number using a dictionary (m)
- Use a min heap to store the k most frequent numbers
- If the min heap size exceeds k, remove the smallest element from the heap
- Return the k most frequent numbers in sorted order"
5686,M) Top K,7. Kth Largest Number in a Stream.py,"

from heapq import heappush, heappop

class KthLargestNumberInStream:
def __init__(self, nums, k):
self.k = k
self.min_heap = []
for num in nums:
_ = self.add(num)


def add(self, num):
heappush(self.min_heap, num)
if len(self.min_heap) > self.k:
heappop(self.min_heap)
return self.min_heap[0]



kthLargestNumber = KthLargestNumberInStream([3, 1, 5, 12, 2, 11], 4)","The most important step to remember is:

1. After adding a number to the min_heap, check if the length of the min_heap is greater than k. If it is, remove the smallest element from the min_heap using heappop."
5687,M) Top K,9. Max Distinct Elements (medium).py,"

from heapq import heappush, heappop

def find_maximum_distinct_elements(nums, k):
distinctElementsCount = 0
if len(nums) <= k:
return distinctElementsCount


numFrequencyMap = {}
for i in nums:
numFrequencyMap[i] = numFrequencyMap.get(i, 0) + 1

minHeap = []

for num, frequency in numFrequencyMap.items():
if frequency == 1:
distinctElementsCount += 1
else:
heappush(minHeap, (frequency, num))


while k > 0 and minHeap:
frequency, num = heappop(minHeap)

k -= frequency - 1
if k >= 0:
distinctElementsCount += 1


if k > 0:
distinctElementsCount -= k

return distinctElementsCount
","1. Construct a frequency map of the input numbers.
2. For each number in the frequency map, if it has a frequency of 1, increment the count of distinct elements. Otherwise, push the frequency and number onto a min-heap.
3. While there is still capacity (k > 0) and the min-heap is not empty, pop the element with the lowest frequency from the min-heap.
4. Subtract the frequency by 1 (as we are using one element) and decrement k accordingly.
5. If there is still capacity (k >= 0), increment the count of distinct elements.
6. If there is still capacity remaining (k > 0), subtract the remaining capacity from the count of distinct elements.
7. Return the count of distinct elements."
5688,M) Top K,4. Connect Ropes (easy).py,"

from heapq import heappush, heappop

def minimum_cost_to_connect_ropes(ropes):
min_heap = []

for i in range(len(ropes)):
heappush(min_heap, ropes[i])

result = 0
while len(min_heap) > 1:
tmp = heappop(min_heap) + heappop(min_heap)
result = result + tmp
heappush(min_heap, tmp)
return result




","- The most important step to remember is to use the `heappush()` function to add the ropes to the min_heap.
- Another important step is to use the `heappop()` function to remove the smallest two ropes from the min_heap and add their sum to the result."
5689,M) Top K,3. Kth closest point to origin (easy).py,"

from heapq import heappush, heappop
from math import sqrt

def find_closest_points(points, k):
min_heap = []
for point in points:
dist = sqrt((point[0] - 0)**2 + (point[1] - 0)**2)
tup = (dist, point[0], point[1])
heappush(min_heap, tup)

res = []
for _ in range(k):
p = heappop(min_heap)
res.append([p[1], p[2]])
return res


","- Create a min heap to store the distances of points from the origin.
- Calculate the distance of each point from the origin and add it to the min heap.
- Pop the k points with the smallest distances from the min heap."
